{"version":3,"sources":["constants.js","actions/index.js","util/AlgorithmUtil.js","util/GridGenerationUtil.js","reducers/index.js","components/Node.js","components/Grid.js","util/algorithms/BFS.js","util/algorithms/DFS.js","util/algorithms/AStar.js","util/algorithms/Greedy.js","components/SelectAlgorithmDropdown.js","components/Menu.js","components/InfoPanel.js","components/App.js","index.js"],"names":["gridDetails","defaultStatistics","wall","unvisited","visited","backtrack","frontier","path","dispatchMultipleActions","actions","i","length","TOTAL_ROW","TOTAL_COL","sleep","ms","Promise","resolve","setTimeout","getNodeNeighbours","state","node","neighbours","row","upNode","col","push","rightNode","downNode","leftNode","isAlgorithmRunning","store","getState","algorithmStatus","isAlgorithmPaused","isAlgorithmStopped","isShowingPath","showPath","togglePathNode","endRow","endCol","a","dispatch","type","finishNode","currentNode","stack","Stack","undefined","previousNode","isEmpty","pop","calculateMahattanDistance","nodeRow","nodeCol","targetRow","targetCol","Math","abs","updatePqueue","pqueue","fCost","newPqueue","MinPriorityQueue","priority","inQueue","frontierNode","dequeue","element","enqueue","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","NodeFactory","isStart","isFinish","distance","Infinity","isVisited","isWall","isFrontier","isHead","isBacktrack","isPath","hCost","gCost","generateInitalGrid","grid","r","currentRow","c","generatePlainGrid","currentGrid","newGrid","slice","newNode","generateToggleWallGrid","generateToggleFrontierGrid","generateMarkVisitedGrid","generateMarkPathGrid","generateGridWithWalls","generateMarkHeadGrid","generateUnmarkHeadGrid","generateMarkBacktrackGrid","array","generateNewStartGrid","generateNewEndGrid","generateNodeKey","toString","getStatistics","stats","generateRandomGrid","random","initialMoveStartEnd","start","isStartMoving","end","isEndMoving","combineReducers","action","selectedAlgorithm","board","statistics","payload","dataStructure","isMousePressed","moveStartEnd","Node","props","onMouseDownHandler","bind","onMouseEnterHandler","onMouseUpHandler","this","toggleWallNode","mouseIsPressed","startNodeMoving","endNodeMoving","onMouseDownActions","mouseIsNotPressed","setStartNode","setEndNode","nodeType","value","id","className","onMouseDown","onMouseUp","onMouseEnter","React","Component","connect","ownProps","isMoving","Grid","map","rowIndex","key","colIndex","BFS","startNode","toggleVisitedNode","toggleFrontierNode","setDataStructure","queue","Queue","neighbour","DFS","markHeadNode","unmarkHeadNode","markBacktrackNodes","stacks","unvisitedStack","visitedStack","wasBacktracking","removeFromStack","filter","backtrackNodes","visitedNode","contains","peek","target","newStack","tempStack","current","AStar","tempG","tempF","Greedy","options","text","SelectAlgorithmDropdown","selectedAlgorithmText","disabled","Dropdown","fluid","simple","item","onChange","event","data","algorithm","Menu","runSelectedAlgorithm","clearBoard","runAlgorithm","pauseAlgorithm","completeAlgorithm","bfs","run","dfs","aStar","greedy","clearWall","notShowingPath","stopAlgorithm","resetDataStructure","showInitialBoard","resetBoardWithWalls","endNode","clearBoardActions","runButtonClass","canGenerateRandomGrid","randomGridButtonClass","runButtonText","onClick","InfoPanel","displayValue","style","width","margin","marginTop","class","border","borderRadius","App","createStore","reducer","window","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","render","document","querySelector"],"mappings":"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","file":"static/js/main.8226b71a.chunk.js","sourcesContent":["export const gridDetails = {\r\n    TOTAL_ROW: 21,\r\n    TOTAL_COL: 50,\r\n    START_NODE_ROW: 10,\r\n    START_NODE_COL: 5,\r\n    FINISH_NODE_ROW: 10,\r\n    FINISH_NODE_COL: 45 \r\n}\r\n\r\nexport const defaultStatistics = {\r\n    wall: 0,\r\n    unvisited: gridDetails.TOTAL_ROW * gridDetails.TOTAL_COL - 2,\r\n    visited: 0,\r\n    backtrack: 0,\r\n    frontier: 0,\r\n    path: 0\r\n}\r\n\r\nexport const wallRatio = 0.3;","export const toggleWallNode = (row, col) => {\r\n    return {\r\n        type: 'TOOGLE_WALL_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const mouseIsPressed = () => {\r\n    return { type: 'PRESSED'};\r\n}\r\n\r\nexport const mouseIsNotPressed = () => {\r\n    return { type: 'NOT_PRESSED'};\r\n}\r\n\r\nexport const dispatchMultipleActions = (actions) => {\r\n    for(let i = 0; i < actions.length; i++) {\r\n        actions[i]();\r\n    }\r\n}\r\n\r\nexport const runAlgorithm = () => {\r\n    return { type: 'RUN_ALGORITHM'};\r\n}\r\n\r\nexport const stopAlgorithm = () => {\r\n    return { type: 'STOP_ALGORITHM'};\r\n}\r\n\r\nexport const showInitialBoard = (endNode) => {\r\n    return { \r\n        type: 'SHOW_INITIAL_BOARD',\r\n        payload: {\r\n            row: endNode.row,\r\n            col: endNode.col\r\n        }\r\n    };\r\n}\r\n\r\nexport const resetBoardWithWalls = (endNode) => {\r\n    return { \r\n        type: 'RESET_BOARD_WITH_WALLS',\r\n        payload: {\r\n            row: endNode.row,\r\n            col: endNode.col\r\n        }\r\n    };\r\n}\r\n\r\nexport const generateRandomGrid = (endNode) => {\r\n    return { \r\n        type: 'GENERATE_RANDOM_GRID',\r\n        payload: {\r\n            row: endNode.row,\r\n            col: endNode.col\r\n        }\r\n    };\r\n}\r\n\r\nexport const pauseAlgorithm = () => {\r\n    return { type: 'PAUSE_ALGORITHM'};\r\n}\r\n\r\nexport const completeAlgorithm = () => {\r\n    return { type: 'COMPLETE_ALGORITHM'};\r\n}\r\n\r\nexport const toggleFrontierNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_FRONTIER_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const toggleVisitedNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_VISITED_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const togglePathNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_PATH_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const setSelectedAlgorithm = (algorithmName) => {\r\n    return {\r\n        type: algorithmName\r\n    }\r\n}\r\n\r\nexport const resetDataStructure = () => {\r\n    return { type: 'RESET_DATA_STRUCTURE' }\r\n}\r\n\r\nexport const setDataStructure = (dataStructure) => {\r\n    return {\r\n        type: 'SET_DATA_STRUCTURE',\r\n        payload: dataStructure\r\n    }\r\n}\r\n\r\nexport const showingPath = () => {\r\n    return { type: 'SHOWING_PATH' };\r\n}\r\n\r\nexport const notShowingPath = () => {\r\n    return { type: 'NOT_SHOWING_PATH' };\r\n}\r\n\r\nexport const markHeadNode = (row, col) => {\r\n    return {\r\n        type: 'MARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const unmarkHeadNode = (row, col) => {\r\n    return {\r\n        type: 'UNMARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const markBacktrackNodes = (array) => {\r\n    return  {\r\n        type: 'MARK_BACKTRACK_NODE',\r\n        payload: { array }\r\n    }\r\n}\r\n\r\nexport const startNodeMoving = (isMoving) => {\r\n    return { type: (isMoving ? 'START_NODE_MOVING' : 'START_NODE_NOT_MOVING') };\r\n}\r\n\r\nexport const startNodeNotMoving = () => {\r\n    return { type: 'START_NODE_NOT_MOVING' };\r\n}\r\n\r\nexport const endNodeMoving = (isMoving) => {\r\n    return { type: (isMoving? 'END_NODE_MOVING' : 'END_NODE_NOT_MOVING') };\r\n}\r\n\r\nexport const endNodeNotMoving = () => {\r\n    return { type: 'END_NODE_NOT_MOVING' };\r\n}\r\n\r\nexport const setStartNode = (row, col) => {\r\n    return {\r\n        type: 'SET_START_NODE',\r\n        payload: { row, col }\r\n    }\r\n}\r\n\r\nexport const setEndNode = (row, col) => {\r\n    return {\r\n        type: 'SET_END_NODE',\r\n        payload: { row, col }\r\n    }\r\n}","import { gridDetails } from '../constants';\r\nimport { store } from '../index';\r\nimport Stack from '@datastructures-js/stack';\r\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\nimport { showingPath, notShowingPath } from '../actions';\r\n\r\nconst { TOTAL_ROW, TOTAL_COL } = gridDetails;\r\n\r\nexport function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nexport const getNodeNeighbours = (state, node) => {\r\n    let neighbours = [];\r\n\r\n    if(node.row > 0) {\r\n        const upNode = state[node.row - 1][node.col];\r\n        neighbours.push(upNode);\r\n    }\r\n\r\n    if(node.col < (TOTAL_COL - 1)) {\r\n        const rightNode = state[node.row][node.col + 1];\r\n        neighbours.push(rightNode);\r\n    }\r\n\r\n    if(node.row < (TOTAL_ROW - 1)) {\r\n        const downNode = state[node.row + 1][node.col];\r\n        neighbours.push(downNode);\r\n    }\r\n\r\n    if(node.col > 0) {\r\n        const leftNode = state[node.row][node.col - 1];\r\n        neighbours.push(leftNode);\r\n    }\r\n\r\n    return neighbours;\r\n}\r\n\r\nexport const isAlgorithmRunning = () => {\r\n    return (store.getState().algorithmStatus === 'RUNNING');\r\n}\r\n\r\nexport const isAlgorithmPaused = () => {\r\n    return (store.getState().algorithmStatus === 'PAUSED');\r\n}\r\n\r\nexport const isAlgorithmStopped = () => {\r\n    return (store.getState().algorithmStatus === 'STOPPED');\r\n}\r\n\r\nconst isShowingPath = () => {\r\n    return store.getState().isShowingPath;\r\n}\r\n\r\nexport async function showPath(state, togglePathNode, endRow, endCol) {\r\n    store.dispatch(showingPath());\r\n\r\n    const finishNode = state[endRow][endCol];\r\n    let currentNode = finishNode;\r\n    const stack = new Stack();\r\n    while(currentNode !== undefined) {\r\n        stack.push(currentNode);\r\n\r\n        if(!currentNode.previousNode) {\r\n            break;\r\n        }\r\n        currentNode = state[currentNode.previousNode.row][currentNode.previousNode.col];\r\n    }\r\n\r\n    while(!stack.isEmpty()) {\r\n        if(isAlgorithmStopped() || !isShowingPath()) {\r\n            return;\r\n        }\r\n\r\n        let node = stack.pop();\r\n        togglePathNode(node.row, node.col);\r\n        await sleep(20);\r\n    }\r\n\r\n    store.dispatch(notShowingPath());\r\n}\r\n\r\nexport const calculateMahattanDistance = (nodeRow, nodeCol, targetRow, targetCol) => {\r\n    return Math.abs(nodeRow - targetRow) + Math.abs(nodeCol - targetCol);\r\n}\r\n\r\nexport const updatePqueue = (pqueue, node) => {\r\n    const { row, col, fCost } = node;\r\n    const newPqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n    let inQueue = false;\r\n\r\n    while(!pqueue.isEmpty()) {\r\n        const frontierNode = pqueue.dequeue().element;\r\n\r\n        if(frontierNode.row === row && frontierNode.col === col) {\r\n            inQueue = true;\r\n            if(frontierNode.fCost <= fCost) {\r\n                newPqueue.enqueue(frontierNode);\r\n            } else {    \r\n                newPqueue.enqueue(node);\r\n            }\r\n        } else {\r\n            newPqueue.enqueue(frontierNode);\r\n        }\r\n    }\r\n\r\n    if(!inQueue) {\r\n        newPqueue.enqueue(node);\r\n    }\r\n\r\n    return newPqueue;\r\n}","import { gridDetails, defaultStatistics, wallRatio } from '../constants';\r\nimport { calculateMahattanDistance } from './AlgorithmUtil';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL, TOTAL_ROW, TOTAL_COL} = gridDetails;\r\n\r\nfunction NodeFactory(row, col) {\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        isFrontier: false,\r\n        isHead: false,\r\n        isBacktrack: false,\r\n        previousNode: null,\r\n        isPath: false,\r\n        hCost: calculateMahattanDistance(row, col, FINISH_NODE_ROW, FINISH_NODE_COL),\r\n        gCost: null,\r\n        fCost: null\r\n      };\r\n}\r\n\r\nexport function generateInitalGrid() {\r\n    const grid = [];\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        const currentRow = [];\r\n\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            currentRow.push(NodeFactory(r, c));\r\n        }\r\n\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    return grid;\r\n}\r\n\r\nexport function generatePlainGrid(currentGrid, endRow, endCol) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n\r\n            const newNode = NodeFactory(r, c);\r\n\r\n            newNode.isStart = node.isStart;\r\n            newNode.isFinish = node.isFinish;\r\n            newNode.hCost = calculateMahattanDistance(r, c, endRow, endCol);\r\n\r\n            newGrid[r][c] = newNode;\r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateToggleWallGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateToggleFrontierGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isFrontier: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkVisitedGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isVisited: true,\r\n        isFrontier: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkPathGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isPath: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateGridWithWalls(currentGrid, endRow, endCol) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n\r\n            const newNode = NodeFactory(r, c);\r\n\r\n            newNode.isStart = node.isStart;\r\n            newNode.isFinish = node.isFinish;\r\n            newNode.isWall = node.isWall;\r\n            newNode.hCost = calculateMahattanDistance(r, c, endRow, endCol);\r\n\r\n            newGrid[r][c] = newNode;\r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateUnmarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkBacktrackGrid(array, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let i = 0; i < array.length; i++) {\r\n        const { row, col } = array[i];\r\n        const node = newGrid[row][col];\r\n\r\n        const newNode = {\r\n            ...node,\r\n            isBacktrack: true\r\n        };\r\n        newGrid[row][col] = newNode;\r\n    }\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateNewStartGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n\r\n            let isStart = r === row && c === col;\r\n\r\n            const newNode = {\r\n                ...node,\r\n                isStart: isStart\r\n            }\r\n\r\n            // if(isStart) {\r\n            //     newNode.isWall = false;\r\n            //     newNode.isVisited = false;\r\n            //     newNode.isFrontier = false;\r\n            //     newNode.isPath = false;\r\n            // }\r\n\r\n            newGrid[r][c] = newNode;\r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateNewEndGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n\r\n            let isFinish = r === row && c === col;\r\n\r\n            const newNode = {\r\n                ...node,\r\n                isFinish: isFinish,\r\n                hCost: calculateMahattanDistance(r, c, row, col)\r\n            }\r\n\r\n            // if(isFinish) {\r\n            //     newNode.isWall = false;\r\n            //     newNode.isVisited = false;\r\n            //     newNode.isFrontier = false;\r\n            //     newNode.isPath = false;\r\n            // }\r\n\r\n            newGrid[r][c] = newNode;\r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateNodeKey(row, col) {\r\n    return (row * TOTAL_ROW + col).toString();\r\n}\r\n\r\nexport function getStatistics(grid) {\r\n    const stats = { ...defaultStatistics };\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = grid[r][c];\r\n\r\n            if(node.isWall && !node.isFinish && !node.isStart) {\r\n                stats.wall++;\r\n            }\r\n\r\n            if(node.isVisited) {\r\n                stats.visited++;\r\n            }\r\n\r\n            if(node.isBacktrack) {\r\n                stats.backtrack++;\r\n            }\r\n\r\n            if(node.isFrontier) {\r\n                stats.frontier++;\r\n            }\r\n            \r\n            if(node.isPath) {\r\n                stats.path++;\r\n            }\r\n        }\r\n    }\r\n\r\n    stats.unvisited = (TOTAL_ROW * TOTAL_COL - 2) - stats.wall - stats.visited - stats.frontier;\r\n\r\n    return stats;\r\n}\r\n\r\nfunction setAsWall() {\r\n    return Math.random() < wallRatio;\r\n}\r\n\r\nexport function generateRandomGrid(currentGrid, endRow, endCol) {\r\n    const newGrid = generatePlainGrid(currentGrid);\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n            node.hCost = calculateMahattanDistance(r, c, endRow, endCol);\r\n\r\n            if(!node.isStart && !node.isFinish) {\r\n                node.isWall = setAsWall();\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}","import { combineReducers } from 'redux';\r\nimport { defaultStatistics } from '../constants';\r\nimport { gridDetails } from '../constants';\r\nimport { generateInitalGrid,\r\n         generateToggleWallGrid, \r\n         generateToggleFrontierGrid, \r\n         generateMarkVisitedGrid, \r\n         generateMarkPathGrid, \r\n         generateGridWithWalls, \r\n         generateMarkHeadGrid, \r\n         generateUnmarkHeadGrid, \r\n         generateMarkBacktrackGrid, \r\n         getStatistics,\r\n         generateRandomGrid,\r\n         generatePlainGrid,\r\n         generateNewStartGrid,\r\n         generateNewEndGrid } from '../util/GridGenerationUtil';\r\n\r\nconst boardReducer = (state={ grid: generateInitalGrid(), statistics: defaultStatistics }, action) => {\r\n    let newGrid = state.grid;\r\n    let newStatistics = state.statistics;\r\n\r\n    switch(action.type) {\r\n        case 'TOOGLE_WALL_NODE':\r\n            newGrid = generateToggleWallGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'TOGGLE_FRONTIER_NDOE':\r\n            newGrid = generateToggleFrontierGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n            \r\n        case 'TOGGLE_VISITED_NODE':\r\n            newGrid = generateMarkVisitedGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'TOGGLE_PATH_NODE':\r\n            newGrid = generateMarkPathGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'SHOW_INITIAL_BOARD':\r\n            newGrid = generatePlainGrid(state.grid, action.payload.row, action.payload.col);\r\n            break;\r\n\r\n        case 'RESET_BOARD_WITH_WALLS':\r\n            newGrid = generateGridWithWalls(state.grid, action.payload.row, action.payload.col);\r\n            break;\r\n\r\n        case 'MARK_HEAD_NODE':\r\n            newGrid = generateMarkHeadGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'UNMARK_HEAD_NODE':\r\n            newGrid = generateUnmarkHeadGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'MARK_BACKTRACK_NODE':\r\n            newGrid = generateMarkBacktrackGrid(action.payload.array, state.grid);\r\n            break;\r\n\r\n        case 'GENERATE_RANDOM_GRID':\r\n            newGrid = generateRandomGrid(state.grid, action.payload.row, action.payload.col);\r\n            break;\r\n\r\n        case 'SET_START_NODE':\r\n            newGrid = generateNewStartGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'SET_END_NODE':\r\n            newGrid = generateNewEndGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        default:\r\n            break;\r\n    }\r\n\r\n    newStatistics = getStatistics(newGrid);\r\n    return { grid: newGrid, statistics: newStatistics };\r\n}\r\n\r\nconst dataStructureReducer = (state=null, action) => {\r\n    switch(action.type) {\r\n        case 'RESET_DATA_STRUCTURE':\r\n            return null;\r\n\r\n        case 'SET_DATA_STRUCTURE':\r\n            return action.payload;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst mousePressedReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'PRESSED':\r\n            return true;\r\n\r\n        case 'NOT_PRESSED':\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst selectAlgorithmReducer = (state='none', action) => {\r\n    switch(action.type) {\r\n        case 'BFS':\r\n            return 'BFS';\r\n\r\n        case 'DFS':\r\n            return 'DFS';\r\n\r\n        case 'ASTAR':\r\n            return 'ASTAR';\r\n\r\n        case 'GREED':\r\n            return 'GREED';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst algorithmStatusReducer = (state='STOPPED', action) => {\r\n    switch(action.type) {\r\n        case 'RUN_ALGORITHM':\r\n            return 'RUNNING';\r\n\r\n        case 'STOP_ALGORITHM':\r\n            return 'STOPPED';\r\n\r\n        case 'PAUSE_ALGORITHM':\r\n            return 'PAUSED';\r\n\r\n        case 'COMPLETE_ALGORITHM':\r\n            return 'COMPLETE';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst isShowingPathReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'SHOWING_PATH':\r\n            return true;\r\n\r\n        case 'NOT_SHOWING_PATH':\r\n            return false;\r\n        \r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst initialMoveStartEnd = {\r\n    start: { row: gridDetails.START_NODE_ROW, col: gridDetails.START_NODE_COL },\r\n    isStartMoving: false,\r\n    end: { row: gridDetails.FINISH_NODE_ROW, col: gridDetails.FINISH_NODE_COL },\r\n    isEndMoving: false\r\n}\r\n\r\nconst moveStartEndReducer = (state=initialMoveStartEnd, action) => {\r\n    switch(action.type) {\r\n        case 'START_NODE_MOVING':\r\n            return { ...state, isStartMoving: true};\r\n\r\n        case 'START_NODE_NOT_MOVING':\r\n            return { ...state, isStartMoving: false};\r\n\r\n        case 'END_NODE_MOVING':\r\n            return { ...state, isEndMoving: true};\r\n\r\n        case 'END_NODE_NOT_MOVING':\r\n            return { ...state, isEndMoving: false};\r\n\r\n        case 'SET_START_NODE':\r\n            return { ...state, \r\n                    start: {\r\n                        row: action.payload.row,\r\n                        col: action.payload.col} \r\n                    }\r\n\r\n        case 'SET_END_NODE':\r\n            return { ...state, \r\n                    end: {\r\n                        row: action.payload.row,\r\n                        col: action.payload.col} \r\n                    }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default combineReducers({\r\n    algorithmStatus: algorithmStatusReducer,\r\n    selectedAlgorithm: selectAlgorithmReducer,\r\n    isShowingPath: isShowingPathReducer,\r\n    board: boardReducer,\r\n    dataStructure: dataStructureReducer,\r\n    isMousePressed: mousePressedReducer,\r\n    moveStartEnd: moveStartEndReducer\r\n});","import '../css/Node.css';\r\nimport React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { mouseIsNotPressed, \r\n         dispatchMultipleActions, \r\n         toggleWallNode,  \r\n         mouseIsPressed,\r\n         startNodeMoving,\r\n         endNodeMoving,\r\n         setStartNode,\r\n         setEndNode } from '../actions'\r\n\r\nclass Node extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.onMouseDownHandler = this.onMouseDownHandler.bind(this);\r\n        this.onMouseEnterHandler = this.onMouseEnterHandler.bind(this);\r\n        this.onMouseUpHandler = this.onMouseUpHandler.bind(this);\r\n    }\r\n\r\n    onMouseDownHandler() {\r\n        const { \r\n            isFrontier,\r\n            isVisited,\r\n            isFinish,\r\n            isStart,\r\n            dispatchMultipleActions,\r\n            toggleWallNode,\r\n            mouseIsPressed,\r\n            startNodeMoving,\r\n            endNodeMoving,\r\n            algorithmStatus\r\n        } = this.props;\r\n\r\n        const onMouseDownActions = [];\r\n\r\n        if(!isFrontier && !isVisited && !isFinish && !isStart) {\r\n            onMouseDownActions.push(() => toggleWallNode());\r\n        }\r\n\r\n        if(isStart && algorithmStatus === 'STOPPED') {\r\n            onMouseDownActions.push(() => startNodeMoving(true));\r\n        }\r\n\r\n        if(isFinish && algorithmStatus === 'STOPPED') {\r\n            onMouseDownActions.push(() => endNodeMoving(true));\r\n        }\r\n\r\n        onMouseDownActions.push(() => mouseIsPressed());\r\n        dispatchMultipleActions(onMouseDownActions);\r\n    }\r\n\r\n    onMouseUpHandler() {\r\n       const {\r\n           mouseIsNotPressed,\r\n           startNodeMoving,\r\n           endNodeMoving,\r\n           dispatchMultipleActions\r\n       } = this.props;\r\n\r\n       const onMouseDownActions = [];\r\n\r\n       onMouseDownActions.push(() => mouseIsNotPressed());\r\n       onMouseDownActions.push(() => startNodeMoving(false));\r\n       onMouseDownActions.push(() => endNodeMoving(false));\r\n       dispatchMultipleActions(onMouseDownActions);\r\n    }\r\n\r\n    onMouseEnterHandler() {\r\n        const { \r\n            row, col, \r\n            isFrontier,\r\n            isVisited,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            dispatchMultipleActions,\r\n            toggleWallNode,\r\n            isMousePressed,\r\n            isStartMoving,\r\n            isEndMoving,\r\n            setStartNode,\r\n            setEndNode,\r\n        } = this.props;\r\n\r\n        const onMouseDownActions = []\r\n\r\n        if(!isMousePressed) {\r\n            return;\r\n        }\r\n\r\n        if(isStartMoving) {\r\n            if(isFinish) {\r\n                return;\r\n            }\r\n            onMouseDownActions.push(() => setStartNode(row, col));\r\n        }\r\n\r\n        if(isEndMoving) {\r\n            if(isStart) {\r\n                return;\r\n            }\r\n            onMouseDownActions.push(() => setEndNode(row, col));\r\n        }\r\n\r\n        if(!isStartMoving && !isEndMoving && !isWall && !isFrontier && !isVisited && !isFinish && !isStart) {\r\n            onMouseDownActions.push(() => toggleWallNode());\r\n        }\r\n\r\n        dispatchMultipleActions(onMouseDownActions);\r\n    }\r\n\r\n    render() {\r\n\r\n        const { \r\n            row, col, \r\n            isStart, isFinish, isWall, isHead, isVisited, isFrontier, isPath, isBacktrack, fCost, \r\n            selectedAlgorithm, \r\n         } = this.props;\r\n\r\n\r\n        const nodeType = isFinish\r\n                        ? 'node-finish'\r\n                        : isStart\r\n                        ? 'node-start'\r\n                        : isPath\r\n                        ? 'node-path'\r\n                        : isWall\r\n                        ? 'node-wall'\r\n                        : isHead\r\n                        ? 'node-head'\r\n                        : isBacktrack\r\n                        ? 'node-backtrack'\r\n                        : isVisited\r\n                        ? 'node-visited'\r\n                        : isFrontier\r\n                        ? 'node-frontier'\r\n                        : ''\r\n\r\n        const value = ((selectedAlgorithm === 'ASTAR' || selectedAlgorithm === 'GREED') && (fCost !== null)) ? fCost : ''\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className={`node ${nodeType}`}\r\n                onMouseDown={this.onMouseDownHandler}\r\n                onMouseUp={this.onMouseUpHandler}\r\n                onMouseEnter={this.onMouseEnterHandler}>\r\n                {value}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n    const node = state.board.grid[ownProps.row][ownProps.col];\r\n    const { moveStartEnd } = state;\r\n\r\n    return {\r\n        isStart:  node.isStart,\r\n        isFinish: node.isFinish,\r\n        isWall: node.isWall,\r\n        isFrontier: node.isFrontier,\r\n        isVisited: node.isVisited,\r\n        isPath: node.isPath,\r\n        isHead: node.isHead,\r\n        isBacktrack: node.isBacktrack,\r\n        isMousePressed: state.isMousePressed,\r\n        hCost: node.hCost,\r\n        gCost: node.gCost,\r\n        fCost: node.fCost,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isStartMoving: moveStartEnd.isStartMoving,\r\n        isEndMoving: moveStartEnd.isEndMoving\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch, ownProps) => {\r\n    return {\r\n        toggleWallNode: () => dispatch(toggleWallNode(ownProps.row, ownProps.col)),\r\n        mouseIsPressed: () => dispatch(mouseIsPressed()),\r\n        mouseIsNotPressed: () => dispatch(mouseIsNotPressed()),\r\n        dispatchMultipleActions: (actions) => dispatchMultipleActions(actions),\r\n        startNodeMoving: (isMoving) => dispatch(startNodeMoving(isMoving)),\r\n        endNodeMoving: (isMoving) => dispatch(endNodeMoving(isMoving)),\r\n        setStartNode: (row, col) => dispatch(setStartNode(row, col)),\r\n        setEndNode: (row, col) => dispatch(setEndNode(row, col))\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Node);","import React from 'react';\r\nimport Node from './Node';\r\nimport { connect } from 'react-redux';\r\nimport '../css/Grid.css';\r\nimport { generateNodeKey } from '../util/GridGenerationUtil';\r\n\r\nclass Grid extends React.Component {\r\n\r\n    render() {\r\n        const { grid } = this.props;\r\n\r\n        return (\r\n            <div className=\"grid\">\r\n                {\r\n                    grid.map((row, rowIndex) => {\r\n                        return (\r\n                            <div className=\"grid-row\" key={rowIndex}>\r\n                                {\r\n                                    row.map((col, colIndex) => {\r\n                                        return (<Node \r\n                                                    key={generateNodeKey(rowIndex, colIndex)}\r\n                                                    row={rowIndex} \r\n                                                    col={colIndex}/>);\r\n                                    })\r\n                                }\r\n                            </div>\r\n                        )\r\n                        \r\n                    })\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.board.grid,\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Grid);","import { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\nimport Queue from 'queue-fifo';\r\n  \r\nexport default class BFS {\r\n    constructor(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure) {\r\n        this.startNode = startNode;\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, queue) {\r\n        if(queue === null) {\r\n            queue = new Queue();\r\n            const startNode = grid[this.startNode.row][this.startNode.col];\r\n            queue.enqueue(startNode);\r\n        }\r\n\r\n        while(!queue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = queue.dequeue();\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.isFinish) {\r\n                await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                // if(neighbour.isFinish) {\r\n                //     await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                //     return;\r\n                // }\r\n                if(!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) {\r\n                    neighbour.isFrontier = true;\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n                    queue.enqueue(neighbour);\r\n                }\r\n            }\r\n            await sleep(0);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(queue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n        \r\n    }\r\n}\r\n","import { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\nimport Stack from '@datastructures-js/stack';\r\n\r\nexport default class DFS {\r\n    constructor(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, markBacktrackNodes, setDataStructure) {\r\n        this.startNode = startNode;\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.markHeadNode = markHeadNode;\r\n        this.unmarkHeadNode = unmarkHeadNode;\r\n        this.markBacktrackNodes = markBacktrackNodes;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, stacks) {\r\n        let unvisitedStack = null;\r\n        let visitedStack = null;\r\n        let wasBacktracking = null;\r\n\r\n        if(stacks === null) {\r\n            unvisitedStack = new Stack();\r\n            const startNode = grid[this.startNode.row][this.startNode.col];\r\n            unvisitedStack.push(startNode);\r\n\r\n            visitedStack = new Stack();\r\n            wasBacktracking = false;\r\n        } else {\r\n            unvisitedStack = stacks.unvisitedStack;\r\n            visitedStack = stacks.visitedStack;\r\n            wasBacktracking = stacks.wasBacktracking;\r\n        }\r\n\r\n        while(!unvisitedStack.isEmpty() && isAlgorithmRunning()) {\r\n            if(wasBacktracking) {\r\n                wasBacktracking = await this.backtrack(visitedStack, unvisitedStack, grid);\r\n                await sleep(20);\r\n                continue;\r\n            }\r\n\r\n\r\n            const currentNode = unvisitedStack.pop();\r\n            unvisitedStack = this.removeFromStack(unvisitedStack, currentNode);\r\n\r\n            currentNode.isVisited = true;\r\n            currentNode.isHead = true;\r\n            this.markHeadNode(currentNode.row, currentNode.col);\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.previousNode !== null) {\r\n                const { row, col } = currentNode.previousNode;\r\n                grid[row][col].isHead = false;\r\n                this.unmarkHeadNode(row, col);\r\n            }\r\n\r\n            if(currentNode.isFinish) {\r\n                await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = neighbours.length - 1; i >= 0; i--) {\r\n                const neighbour = neighbours[i];\r\n                if((!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) || neighbour.isFinish) {\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    unvisitedStack.push(neighbour);\r\n                }\r\n            }\r\n\r\n            visitedStack.push(currentNode);\r\n\r\n            const validNeighbours = neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier)\r\n\r\n            if(validNeighbours.length === 0) {\r\n                currentNode.isHead = false;\r\n                this.unmarkHeadNode(currentNode.row, currentNode.col);\r\n                await sleep(20);\r\n                wasBacktracking = await this.backtrack(visitedStack, unvisitedStack, grid);\r\n               \r\n            }\r\n\r\n            await sleep(40);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure({ unvisitedStack: unvisitedStack, visitedStack: visitedStack, wasBacktracking: wasBacktracking });\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    async backtrack(visitedStack, unvisitedStack, grid) {\r\n\r\n        let backtrackNodes = [];\r\n\r\n        while(!visitedStack.isEmpty() && !unvisitedStack.isEmpty() && isAlgorithmRunning()) {\r\n            const visitedNode = visitedStack.pop();\r\n\r\n            let neighbours = getNodeNeighbours(grid, visitedNode);\r\n            neighbours = neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier)\r\n            if(this.contains(neighbours, unvisitedStack.peek())) {\r\n                visitedStack.push(visitedNode);\r\n                this.markBacktrackNodes(backtrackNodes);\r\n                return;\r\n            } else {\r\n                backtrackNodes.push(visitedNode);\r\n            }   \r\n        }\r\n\r\n    }\r\n\r\n    contains(neighbours, target) {\r\n        for(let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            if(neighbour.row === target.row && neighbour.col === target.col) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n\r\n        return false;\r\n    }\r\n\r\n    removeFromStack(stack, target) {\r\n        const newStack = new Stack();\r\n        const tempStack = new Stack();\r\n\r\n        while(!stack.isEmpty()) {\r\n            const current = stack.pop();\r\n            if(current.row === target.row && current.col === target.col) {\r\n                continue;\r\n            }\r\n\r\n            tempStack.push(current);\r\n        }\r\n\r\n        while(!tempStack.isEmpty()) {\r\n            newStack.push(tempStack.pop());\r\n        }\r\n\r\n        return newStack;\r\n    }\r\n}\r\n","import { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath, updatePqueue } from '../AlgorithmUtil';\r\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\nexport default class AStar {\r\n    constructor(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure) {\r\n        this.startNode = startNode;\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, pqueue) {\r\n        if(pqueue === null) {\r\n            pqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n            const startNode = grid[this.startNode.row][this.startNode.col];\r\n            startNode.gCost = 0;\r\n            startNode.fCost = startNode.gCost + startNode.hCost;\r\n            pqueue.enqueue(startNode);\r\n        }\r\n\r\n\r\n        while(!pqueue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = pqueue.dequeue().element;\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.isFinish) {\r\n                await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                \r\n                if((!neighbour.isWall && !neighbour.isVisited) || neighbour.isFinish) {\r\n                    const tempG = currentNode.gCost + 1;\r\n                    const tempF = tempG + neighbour.hCost;\r\n                    if(neighbour.gCost !== null) {\r\n                        if(tempF < neighbour.fCost) {\r\n                            neighbour.gCost = tempG;\r\n                            neighbour.fCost = tempF;\r\n                            neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                            pqueue = updatePqueue(pqueue, neighbour);\r\n                        } \r\n                    } else {\r\n                        neighbour.gCost = tempG;\r\n                        neighbour.fCost = tempF;\r\n                        pqueue.enqueue(neighbour);\r\n                        neighbour.isFrontier = true;\r\n                        neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    }\r\n\r\n                    this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n                }\r\n            }\r\n\r\n            await sleep(40);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(pqueue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n}","import { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath, updatePqueue } from '../AlgorithmUtil';\r\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\nexport default class Greedy {\r\n    constructor(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure) {\r\n        this.startNode = startNode;\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, pqueue) {\r\n        if(pqueue === null) {\r\n            pqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n            const startNode = grid[this.startNode.row][this.startNode.col];\r\n            startNode.fCost = startNode.hCost;\r\n            pqueue.enqueue(startNode);\r\n        }\r\n\r\n\r\n        while(!pqueue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = pqueue.dequeue().element;\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.isFinish) {\r\n                await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                if((!neighbour.isWall && !neighbour.isVisited) || neighbour.isFinish) {\r\n\r\n                    if(!neighbour.isFrontier) {\r\n                        neighbour.isFrontier = true;\r\n                        neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                        this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n\r\n                        neighbour.fCost = neighbour.hCost;\r\n                        pqueue = updatePqueue(pqueue, neighbour);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            await sleep(40);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(pqueue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n}","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Dropdown } from 'semantic-ui-react';\r\nimport { setSelectedAlgorithm } from '../actions';\r\n\r\nconst options = [\r\n    { key: 1, text: 'Breadth First Search (BFS)', value: 'BFS' },\r\n    { key: 2, text: 'Depth First Search (DFS)', value: 'DFS' },\r\n    { key: 3, text: 'A* Search', value: 'ASTAR' },\r\n    { key: 4, text: 'Greedy Best-First Search', value: 'GREED' }\r\n  ]\r\n\r\nclass SelectAlgorithmDropdown extends React.Component {\r\n    render() {\r\n        const selectedAlgorithmText = this.props.selectedAlgorithm === 'none' ? 'Select Algorithm' \r\n                                                                              : this.props.selectedAlgorithm === 'BFS'\r\n                                                                              ? 'Breadth First Search (BFS)'\r\n                                                                              : this.props.selectedAlgorithm === 'DFS'\r\n                                                                              ? 'Depth First Search (BFS)'\r\n                                                                              : this.props.selectedAlgorithm === 'ASTAR'\r\n                                                                              ? 'A* Search'\r\n                                                                              : this.props.selectedAlgorithm === 'GREED'\r\n                                                                              ? 'Greedy Best-First Search'\r\n                                                                              : 'Select Algorithm';\r\n\r\n        const disabled = this.props.algorithmStatus !== 'STOPPED';\r\n\r\n        return (\r\n            <Dropdown \r\n                fluid text={selectedAlgorithmText} \r\n                options={options} \r\n                simple item onChange={(event, data) => {this.props.onChange(data.value)}}\r\n                disabled={disabled}/>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        onChange: (algorithm) => {dispatch(setSelectedAlgorithm(algorithm))}\r\n    }\r\n}\r\n  \r\nexport default connect(mapStateToProps, mapDispatchToProps)(SelectAlgorithmDropdown)","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport BFS from '../util/algorithms/BFS';\r\nimport DFS from '../util/algorithms/DFS';\r\nimport AStar from '../util/algorithms/AStar';\r\nimport Greedy from '../util/algorithms/Greedy';\r\nimport { isAlgorithmRunning } from '../util/AlgorithmUtil'\r\nimport SelectAlgorithmDropdown from './SelectAlgorithmDropdown';\r\nimport { showInitialBoard, \r\n        runAlgorithm, \r\n        stopAlgorithm, \r\n        pauseAlgorithm, \r\n        completeAlgorithm, \r\n        toggleFrontierNode, \r\n        toggleVisitedNode, \r\n        togglePathNode, \r\n        resetDataStructure, \r\n        setDataStructure, \r\n        notShowingPath, \r\n        markHeadNode, \r\n        unmarkHeadNode, \r\n        resetBoardWithWalls, \r\n        markBacktrackNodes,\r\n        generateRandomGrid,\r\n        dispatchMultipleActions } from '../actions';\r\n\r\nclass Menu extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.runSelectedAlgorithm = this.runSelectedAlgorithm.bind(this);\r\n        this.clearBoard = this.clearBoard.bind(this);\r\n    }\r\n\r\n    async runSelectedAlgorithm() {\r\n        const { \r\n            selectedAlgorithm, \r\n            runAlgorithm, \r\n            pauseAlgorithm,\r\n            completeAlgorithm, \r\n            grid,\r\n            dataStructure,\r\n            toggleVisitedNode, \r\n            toggleFrontierNode, \r\n            togglePathNode,\r\n            setDataStructure,\r\n            isShowingPath,\r\n            markHeadNode,\r\n            unmarkHeadNode,\r\n            algorithmStatus,\r\n            markBacktrackNodes,\r\n            startNode\r\n        } = this.props;\r\n\r\n        if(selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') {\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmRunning()) {\r\n            pauseAlgorithm();\r\n            return;\r\n        }\r\n\r\n        runAlgorithm();\r\n\r\n        switch(selectedAlgorithm) {\r\n            case \"BFS\":\r\n                const bfs = new BFS(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure);\r\n                await bfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"DFS\":\r\n                const dfs = new DFS(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, markBacktrackNodes, setDataStructure);\r\n                await dfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"ASTAR\":\r\n                const aStar = new AStar(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure);\r\n                await aStar.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"GREED\":\r\n                const greedy = new Greedy(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure);\r\n                await greedy.run(grid, dataStructure);\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        \r\n        if(isAlgorithmRunning()) {\r\n            completeAlgorithm();\r\n        }\r\n\r\n    }\r\n\r\n    clearBoard(clearWall) {\r\n        const { \r\n            notShowingPath,\r\n            stopAlgorithm,\r\n            resetDataStructure,\r\n            showInitialBoard,\r\n            resetBoardWithWalls,\r\n            dispatchMultipleActions,\r\n            endNode\r\n        } = this.props;\r\n\r\n        const clearBoardActions = [notShowingPath,\r\n                                   stopAlgorithm,\r\n                                   resetDataStructure];\r\n\r\n        if(clearWall) {\r\n            clearBoardActions.push(() => showInitialBoard(endNode));\r\n        } else {\r\n            clearBoardActions.push(() => resetBoardWithWalls(endNode));\r\n        }\r\n\r\n        dispatchMultipleActions(clearBoardActions);\r\n    }\r\n\r\n    render() {\r\n        const { selectedAlgorithm, algorithmStatus, isShowingPath, generateRandomGrid, endNode } = this.props;\r\n\r\n        const runButtonClass = (selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') ? \"active item\" : \"item\";\r\n\r\n        const canGenerateRandomGrid = algorithmStatus === 'STOPPED';\r\n\r\n        const randomGridButtonClass = canGenerateRandomGrid ? \"item\" : \"active item\"; \r\n\r\n        let runButtonText = \"Run\";\r\n\r\n        if((algorithmStatus === 'RUNNING' && isShowingPath) || algorithmStatus === 'COMPLETE') {\r\n            runButtonText = \"Complete\";\r\n        }\r\n\r\n        if(algorithmStatus === 'RUNNING' && !isShowingPath) {\r\n            runButtonText = \"Pause\";\r\n        }\r\n\r\n        return (\r\n            <div className=\"ui five item menu\">\r\n                <a  onClick={canGenerateRandomGrid ? () => generateRandomGrid(endNode) : () => {}} className={randomGridButtonClass} >Generate Random Grid</a>\r\n                <SelectAlgorithmDropdown />\r\n                <a onClick={this.runSelectedAlgorithm} className={runButtonClass}>{runButtonText}!</a>\r\n                <a onClick={() => this.clearBoard(false)} className=\"item\">Clear Path</a>\r\n                <a onClick={() => this.clearBoard(true)} className=\"item\">Clear Board</a>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.board.grid,\r\n        dataStructure: state.dataStructure,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isShowingPath: state.isShowingPath,\r\n        statistics: state.board.statistics,\r\n        startNode: state.moveStartEnd.start,\r\n        endNode: state.moveStartEnd.end\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        showInitialBoard: (endNode) => dispatch(showInitialBoard(endNode)),\r\n        runAlgorithm: () => dispatch(runAlgorithm()),\r\n        stopAlgorithm: () => dispatch(stopAlgorithm()),\r\n        pauseAlgorithm: () => dispatch(pauseAlgorithm()),\r\n        completeAlgorithm: () => dispatch(completeAlgorithm()),\r\n        toggleVisitedNode: (row, col) => dispatch(toggleVisitedNode(row, col)),\r\n        toggleFrontierNode: (row, col) => dispatch(toggleFrontierNode(row, col)),\r\n        togglePathNode: (row, col) => dispatch(togglePathNode(row, col)),\r\n        resetDataStructure: () => dispatch(resetDataStructure()),\r\n        setDataStructure: (dataStructure) => dispatch(setDataStructure(dataStructure)),\r\n        notShowingPath: () => dispatch(notShowingPath()),\r\n        markHeadNode: (row, col) => dispatch(markHeadNode(row, col)),\r\n        unmarkHeadNode: (row, col) => dispatch(unmarkHeadNode(row, col)),\r\n        resetBoardWithWalls: (endNode) => dispatch(resetBoardWithWalls(endNode)),\r\n        markBacktrackNodes: (array) => dispatch(markBacktrackNodes(array)),\r\n        generateRandomGrid: (endNode) => dispatch(generateRandomGrid(endNode)),\r\n        dispatchMultipleActions: (actions) => dispatchMultipleActions(actions)\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Menu);","import React from 'react';\r\nimport { connect } from 'react-redux';\r\n\r\nclass InfoPanel extends React.Component {\r\n    render() {\r\n\r\n        const { unvisited,\r\n                visited,\r\n                wall,\r\n                backtrack,\r\n                frontier,\r\n                path } = this.props.statistics;\r\n\r\n        const displayValue = (value) => (value === 0) ? \"\" : `${value} ` \r\n\r\n\r\n        return (\r\n            <div style={{width: \"85%\", margin: \"auto\", marginTop: \"2vh\"}}>\r\n                <div className=\"ui small eight statistics\">\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">\r\n                            <div className={`node node-start`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} />\r\n                        </div>\r\n                        <div class=\"label\">start</div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">\r\n                            <div className={`node node-finish`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} />\r\n                        </div>\r\n                        <div class=\"label\">end</div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(unvisited)} <div className={`node node-unvisited`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>unvisited</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(wall)} <div className={`node node-wall`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>wall</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(visited)} <div className={`node node-visited`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>visited</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(backtrack)} <div className={`node node-backtrack`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>backtrack</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(frontier)} <div className={`node node-frontier`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>frontier</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(path)} <div className={`node node-path`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>path</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n   \r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.board.grid,\r\n        dataStructure: state.dataStructure,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isShowingPath: state.isShowingPath,\r\n        statistics: state.board.statistics\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(InfoPanel);","import React from 'react';\r\nimport Grid from './Grid';\r\nimport Menu from './Menu';\r\nimport InfoPanel from './InfoPanel';\r\nimport '../css/App.css';\r\n\r\nclass App extends React.Component {\r\n\r\n    render() {\r\n        return (\r\n            <div id=\"wrapper\" className=\"App\">\r\n                <Menu/>\r\n                <Grid />\r\n                <InfoPanel/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport { createStore } from 'redux';\r\nimport reducer from './reducers';\r\nimport App from './components/App';\r\nimport './css/App.css';\r\n\r\nexport const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\r\n\r\nReactDOM.render(<Provider store={store}><App /></Provider>, document.querySelector('#root'));\r\n"],"sourceRoot":""}