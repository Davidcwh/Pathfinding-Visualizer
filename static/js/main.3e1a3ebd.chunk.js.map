{"version":3,"sources":["constants.js","actions/index.js","util/AlgorithmUtil.js","util/GridGenerationUtil.js","reducers/index.js","components/Node.js","components/Grid.js","util/algorithms/BFS.js","util/algorithms/DFS.js","util/algorithms/AStar.js","util/algorithms/Greedy.js","components/SelectAlgorithmDropdown.js","components/Menu.js","components/InfoPanel.js","components/App.js","index.js"],"names":["gridDetails","defaultStatistics","show","wall","unvisited","visited","backtrack","frontier","path","updateStatistics","grid","type","payload","resetStatistics","resetWall","TOTAL_ROW","TOTAL_COL","FINISH_NODE_ROW","FINISH_NODE_COL","sleep","ms","Promise","resolve","setTimeout","getNodeNeighbours","state","node","neighbours","row","upNode","col","push","rightNode","downNode","leftNode","isAlgorithmRunning","store","getState","algorithmStatus","isAlgorithmPaused","isAlgorithmStopped","isShowingPath","showPath","togglePathNode","a","dispatch","finishNode","currentNode","stack","Stack","undefined","previousNode","isEmpty","pop","updatePqueue","pqueue","fCost","newPqueue","MinPriorityQueue","priority","inQueue","frontierNode","dequeue","element","enqueue","START_NODE_ROW","START_NODE_COL","NodeFactory","isStart","isFinish","distance","Infinity","isVisited","isWall","isFrontier","isHead","isBacktrack","isPath","hCost","nodeRow","nodeCol","targetRow","targetCol","Math","abs","gCost","generateInitalGrid","r","currentRow","c","generateToggleWallGrid","currentGrid","newGrid","slice","newNode","generateToggleFrontierGrid","generateMarkVisitedGrid","generateMarkPathGrid","generateGridWithWalls","generateMarkHeadGrid","generateUnmarkHeadGrid","generateMarkBacktrackGrid","array","i","length","generateNodeKey","toString","getStatistics","stats","generateRandomGrid","random","combineReducers","statistics","action","selectedAlgorithm","dataStructure","isMousePressed","connect","ownProps","onMouseDown","toggleWallNode","mouseIsNotPressed","nodeType","value","id","className","onMouseUp","onMouseEnter","Grid","this","props","map","rowIndex","key","colIndex","React","Component","BFS","toggleVisitedNode","toggleFrontierNode","setDataStructure","queue","Queue","startNode","neighbour","DFS","markHeadNode","unmarkHeadNode","markBacktrackNodes","stacks","unvisitedStack","visitedStack","wasBacktracking","removeFromStack","filter","backtrackNodes","visitedNode","contains","peek","target","newStack","tempStack","current","AStar","tempG","tempF","Greedy","options","text","SelectAlgorithmDropdown","selectedAlgorithmText","disabled","Dropdown","fluid","simple","item","onChange","event","data","algorithm","Menu","runSelectedAlgorithm","bind","clearBoard","runAlgorithm","pauseAlgorithm","completeAlgorithm","bfs","run","dfs","aStar","greedy","clearWall","notShowingPath","stopAlgorithm","resetDataStructure","showInitialBoard","resetBoardWithWalls","runButtonClass","canGenerateRandomGrid","randomGridButtonClass","runButtonText","onClick","showStatistics","hideStatistics","InfoPanel","displayValue","style","width","margin","marginTop","class","border","borderRadius","App","createStore","reducer","window","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","render","document","querySelector"],"mappings":"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","file":"static/js/main.3e1a3ebd.chunk.js","sourcesContent":["export const gridDetails = {\r\n    TOTAL_ROW: 21,\r\n    TOTAL_COL: 50,\r\n    START_NODE_ROW: 10,\r\n    START_NODE_COL: 5,\r\n    FINISH_NODE_ROW: 10,\r\n    FINISH_NODE_COL: 45 \r\n}\r\n\r\nexport const defaultStatistics = {\r\n    show: false,\r\n    wall: 0,\r\n    unvisited: gridDetails.TOTAL_ROW * gridDetails.TOTAL_COL - 2,\r\n    visited: 0,\r\n    backtrack: 0,\r\n    frontier: 0,\r\n    path: 0\r\n}\r\n\r\nexport const wallRatio = 0.3;","const toggleWallNode = (row, col) => {\r\n    return {\r\n        type: 'TOOGLE_WALL_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nconst mouseIsPressed = () => {\r\n    return { type: 'PRESSED'};\r\n}\r\n\r\nexport const mouseIsNotPressed = () => {\r\n    return { type: 'NOT_PRESSED'};\r\n}\r\n\r\nexport const onMouseDown = (row, col, dispatch, grid) => {\r\n    dispatch(toggleWallNode(row, col));\r\n    dispatch(mouseIsPressed());\r\n    dispatch(updateStatistics(grid));\r\n}\r\n\r\n\r\nexport const runAlgorithm = () => {\r\n    return { type: 'RUN_ALGORITHM'};\r\n}\r\n\r\nexport const stopAlgorithm = () => {\r\n    return { type: 'STOP_ALGORITHM'};\r\n}\r\n\r\nexport const showInitialBoard = () => {\r\n    return { type: 'SHOW_INITIAL_BOARD'};\r\n}\r\n\r\nexport const resetBoardWithWalls = () => {\r\n    return { type: 'RESET_BOARD_WITH_WALLS'};\r\n}\r\n\r\nexport const generateRandomGrid = () => {\r\n    return { type: 'GENERATE_RANDOM_GRID' };\r\n}\r\n\r\nexport const pauseAlgorithm = () => {\r\n    return { type: 'PAUSE_ALGORITHM'};\r\n}\r\n\r\nexport const completeAlgorithm = () => {\r\n    return { type: 'COMPLETE_ALGORITHM'};\r\n}\r\n\r\nexport const toggleFrontierNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_FRONTIER_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const toggleVisitedNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_VISITED_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const togglePathNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_PATH_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const setSelectedAlgorithm = (algorithmName) => {\r\n    return {\r\n        type: algorithmName\r\n    }\r\n}\r\n\r\nexport const resetDataStructure = () => {\r\n    return { type: 'RESET_DATA_STRUCTURE' }\r\n}\r\n\r\nexport const setDataStructure = (dataStructure) => {\r\n    return {\r\n        type: 'SET_DATA_STRUCTURE',\r\n        payload: dataStructure\r\n    }\r\n}\r\n\r\nexport const showingPath = () => {\r\n    return { type: 'SHOWING_PATH' };\r\n}\r\n\r\nexport const notShowingPath = () => {\r\n    return { type: 'NOT_SHOWING_PATH' };\r\n}\r\n\r\nexport const markHeadNode = (row, col) => {\r\n    return {\r\n        type: 'MARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const unmarkHeadNode = (row, col) => {\r\n    return {\r\n        type: 'UNMARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const markBacktrackNodes = (array) => {\r\n    return  {\r\n        type: 'MARK_BACKTRACK_NODE',\r\n        payload: { array }\r\n    }\r\n}\r\n\r\nexport const updateStatistics = (grid) => {\r\n    return { \r\n        type: 'UPDATE_STATISTICS', \r\n        payload: grid \r\n    };\r\n}\r\n\r\nexport const resetStatistics = (resetWall) => {\r\n    return { \r\n        type: 'RESET_STATISTICS',\r\n        payload: resetWall };\r\n}\r\n\r\nexport const showStatistics = () => {\r\n    return { type: 'SHOW_STATISTICS' };\r\n}\r\n\r\nexport const hideStatistics = () => {\r\n    return { type: 'HIDE_STATISTICS' };\r\n}\r\n","import { gridDetails } from '../constants';\r\nimport { store } from '../index';\r\nimport Stack from '@datastructures-js/stack';\r\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\nimport { showingPath, notShowingPath } from '../actions';\r\n\r\nconst { TOTAL_ROW, TOTAL_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n\r\nexport function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nexport const getNodeNeighbours = (state, node) => {\r\n    let neighbours = [];\r\n\r\n    if(node.row > 0) {\r\n        const upNode = state[node.row - 1][node.col];\r\n        neighbours.push(upNode);\r\n    }\r\n\r\n    if(node.col < (TOTAL_COL - 1)) {\r\n        const rightNode = state[node.row][node.col + 1];\r\n        neighbours.push(rightNode);\r\n    }\r\n\r\n    if(node.row < (TOTAL_ROW - 1)) {\r\n        const downNode = state[node.row + 1][node.col];\r\n        neighbours.push(downNode);\r\n    }\r\n\r\n    if(node.col > 0) {\r\n        const leftNode = state[node.row][node.col - 1];\r\n        neighbours.push(leftNode);\r\n    }\r\n\r\n    return neighbours;\r\n}\r\n\r\nexport const isAlgorithmRunning = () => {\r\n    return (store.getState().algorithmStatus === 'RUNNING');\r\n}\r\n\r\nexport const isAlgorithmPaused = () => {\r\n    return (store.getState().algorithmStatus === 'PAUSED');\r\n}\r\n\r\nexport const isAlgorithmStopped = () => {\r\n    return (store.getState().algorithmStatus === 'STOPPED');\r\n}\r\n\r\nconst isShowingPath = () => {\r\n    return store.getState().isShowingPath;\r\n}\r\n\r\nexport async function showPath(state, togglePathNode, updateStatistics) {\r\n    store.dispatch(showingPath());\r\n\r\n    const finishNode = state[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let currentNode = finishNode;\r\n    const stack = new Stack();\r\n    while(currentNode !== undefined) {\r\n        stack.push(currentNode);\r\n\r\n        if(!currentNode.previousNode) {\r\n            break;\r\n        }\r\n        currentNode = state[currentNode.previousNode.row][currentNode.previousNode.col];\r\n    }\r\n\r\n    while(!stack.isEmpty()) {\r\n        if(isAlgorithmStopped() || !isShowingPath()) {\r\n            return;\r\n        }\r\n\r\n        let node = stack.pop();\r\n        togglePathNode(node.row, node.col);\r\n        updateStatistics(state);\r\n        await sleep(20);\r\n    }\r\n\r\n    store.dispatch(notShowingPath());\r\n}\r\n\r\nexport const calculateMahattanDistance = (nodeRow, nodeCol, targetRow, targetCol) => {\r\n    return Math.abs(nodeRow - targetRow) + Math.abs(nodeCol - targetCol);\r\n}\r\n\r\nexport const updatePqueue = (pqueue, node) => {\r\n    const { row, col, fCost } = node;\r\n    const newPqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n    let inQueue = false;\r\n\r\n    while(!pqueue.isEmpty()) {\r\n        const frontierNode = pqueue.dequeue().element;\r\n\r\n        if(frontierNode.row === row && frontierNode.col === col) {\r\n            inQueue = true;\r\n            if(frontierNode.fCost <= fCost) {\r\n                newPqueue.enqueue(frontierNode);\r\n            } else {    \r\n                newPqueue.enqueue(node);\r\n            }\r\n        } else {\r\n            newPqueue.enqueue(frontierNode);\r\n        }\r\n    }\r\n\r\n    if(!inQueue) {\r\n        newPqueue.enqueue(node);\r\n    }\r\n\r\n    return newPqueue;\r\n}","import { gridDetails, defaultStatistics, wallRatio } from '../constants';\r\nimport { calculateMahattanDistance } from './AlgorithmUtil';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL, TOTAL_ROW, TOTAL_COL} = gridDetails;\r\n\r\nfunction NodeFactory(row, col) {\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        isFrontier: false,\r\n        isHead: false,\r\n        isBacktrack: false,\r\n        previousNode: null,\r\n        isPath: false,\r\n        hCost: calculateMahattanDistance(row, col, FINISH_NODE_ROW, FINISH_NODE_COL),\r\n        gCost: null,\r\n        fCost: null\r\n      };\r\n}\r\n\r\nexport function generateInitalGrid() {\r\n    const grid = [];\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        const currentRow = [];\r\n\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            currentRow.push(NodeFactory(r, c));\r\n        }\r\n\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    return grid;\r\n}\r\n\r\nexport function generateToggleWallGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateToggleFrontierGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isFrontier: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkVisitedGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isVisited: true,\r\n        isFrontier: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkPathGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isPath: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateGridWithWalls(currentGrid) {\r\n    const newGrid = generateInitalGrid();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const currentNode = currentGrid[r][c];\r\n            if(!currentNode.isFinish && !currentNode.isStart) {  \r\n                newGrid[r][c].isWall = currentNode.isWall;\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateUnmarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkBacktrackGrid(array, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let i = 0; i < array.length; i++) {\r\n        const { row, col } = array[i];\r\n        const node = newGrid[row][col];\r\n\r\n        const newNode = {\r\n            ...node,\r\n            isBacktrack: true\r\n        };\r\n        newGrid[row][col] = newNode;\r\n    }\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateNodeKey(row, col) {\r\n    return (row * TOTAL_ROW + col).toString();\r\n}\r\n\r\nexport function getStatistics(grid, show) {\r\n    const stats = { ...defaultStatistics };\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = grid[r][c];\r\n\r\n            if(node.isWall) {\r\n                stats.wall++;\r\n            }\r\n\r\n            if(node.isVisited) {\r\n                stats.visited++;\r\n            }\r\n\r\n            if(node.isBacktrack) {\r\n                stats.backtrack++;\r\n            }\r\n\r\n            if(node.isFrontier) {\r\n                stats.frontier++;\r\n            }\r\n            \r\n            if(node.isPath) {\r\n                stats.path++;\r\n            }\r\n        }\r\n    }\r\n\r\n    stats.unvisited = (TOTAL_ROW * TOTAL_COL - 2) - stats.wall - stats.visited - stats.frontier;\r\n    stats.show = show;\r\n\r\n    return stats;\r\n}\r\n\r\nexport function resetStatistics(wall, resetWall) {\r\n    const stats = { ...defaultStatistics };\r\n\r\n    if(!resetWall) {\r\n        stats.wall = wall;\r\n        stats.unvisited = stats.unvisited - wall;\r\n    }\r\n\r\n    return stats\r\n}\r\n\r\nfunction setAsWall() {\r\n    return Math.random() < wallRatio;\r\n}\r\n\r\nexport function generateRandomGrid() {\r\n    const newGrid = generateInitalGrid();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n\r\n            if(!node.isStart && !node.isFinish) {\r\n                node.isWall = setAsWall();\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}","import { combineReducers } from 'redux';\r\nimport { defaultStatistics } from '../constants';\r\nimport { generateInitalGrid,\r\n         generateToggleWallGrid, \r\n         generateToggleFrontierGrid, \r\n         generateMarkVisitedGrid, \r\n         generateMarkPathGrid, \r\n         generateGridWithWalls, \r\n         generateMarkHeadGrid, \r\n         generateUnmarkHeadGrid, \r\n         generateMarkBacktrackGrid, \r\n         getStatistics,\r\n         resetStatistics,\r\n         generateRandomGrid } from '../util/GridGenerationUtil';\r\n\r\nconst gridReducer = (state=generateInitalGrid(), action) => {\r\n    switch(action.type) {\r\n        case 'TOOGLE_WALL_NODE':\r\n            return generateToggleWallGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'TOGGLE_FRONTIER_NDOE':\r\n            return generateToggleFrontierGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'TOGGLE_VISITED_NODE':\r\n            return generateMarkVisitedGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'TOGGLE_PATH_NODE':\r\n            return generateMarkPathGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'SHOW_INITIAL_BOARD':\r\n            return generateInitalGrid();\r\n\r\n        case 'RESET_BOARD_WITH_WALLS':\r\n            return generateGridWithWalls(state);\r\n\r\n        case 'MARK_HEAD_NODE':\r\n            return generateMarkHeadGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'UNMARK_HEAD_NODE':\r\n            return generateUnmarkHeadGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'MARK_BACKTRACK_NODE':\r\n            return generateMarkBacktrackGrid(action.payload.array, state);\r\n\r\n        case 'GENERATE_RANDOM_GRID':\r\n            return generateRandomGrid();\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst dataStructureReducer = (state=null, action) => {\r\n    switch(action.type) {\r\n        case 'RESET_DATA_STRUCTURE':\r\n            return null;\r\n\r\n        case 'SET_DATA_STRUCTURE':\r\n            return action.payload;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst mousePressedReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'PRESSED':\r\n            return true;\r\n\r\n        case 'NOT_PRESSED':\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst selectAlgorithmReducer = (state='none', action) => {\r\n    switch(action.type) {\r\n        case 'BFS':\r\n            return 'BFS';\r\n\r\n        case 'DFS':\r\n            return 'DFS';\r\n\r\n        case 'ASTAR':\r\n            return 'ASTAR';\r\n\r\n        case 'GREED':\r\n            return 'GREED';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst algorithmStatusReducer = (state='STOPPED', action) => {\r\n    switch(action.type) {\r\n        case 'RUN_ALGORITHM':\r\n            return 'RUNNING';\r\n\r\n        case 'STOP_ALGORITHM':\r\n            return 'STOPPED';\r\n\r\n        case 'PAUSE_ALGORITHM':\r\n            return 'PAUSED';\r\n\r\n        case 'COMPLETE_ALGORITHM':\r\n            return 'COMPLETE';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst isShowingPathReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'SHOWING_PATH':\r\n            return true;\r\n\r\n        case 'NOT_SHOWING_PATH':\r\n            return false;\r\n        \r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst statisticsReducer = (state=defaultStatistics, action) => {\r\n    switch(action.type) {\r\n        case 'UPDATE_STATISTICS':\r\n            return getStatistics(action.payload, state.show);\r\n\r\n        case 'RESET_STATISTICS':\r\n            return resetStatistics(state.wall, action.payload);\r\n\r\n        case 'SHOW_STATISTICS':\r\n            return { ...defaultStatistics, show: true };\r\n\r\n        case 'HIDE_STATISTICS':\r\n            return { ...defaultStatistics, show: false }\r\n        \r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default combineReducers({\r\n    statistics: statisticsReducer,\r\n    algorithmStatus: algorithmStatusReducer,\r\n    selectedAlgorithm: selectAlgorithmReducer,\r\n    isShowingPath: isShowingPathReducer,\r\n    grid: gridReducer,\r\n    dataStructure: dataStructureReducer,\r\n    isMousePressed: mousePressedReducer\r\n});","import '../css/Node.css';\r\nimport React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { mouseIsNotPressed, onMouseDown } from '../actions'\r\n\r\nconst Node = ({ row, col, isStart, isFinish, isWall, isHead, isVisited, isFrontier, isPath, isBacktrack, isMousePressed, onMouseDown, mouseIsNotPressed, fCost, selectedAlgorithm, grid }) => {\r\n    const nodeType = isFinish\r\n        ? 'node-finish'\r\n        : isStart\r\n        ? 'node-start'\r\n        : isPath\r\n        ? 'node-path'\r\n        : isWall\r\n        ? 'node-wall'\r\n        : isHead\r\n        ? 'node-head'\r\n        : isBacktrack\r\n        ? 'node-backtrack'\r\n        : isVisited\r\n        ? 'node-visited'\r\n        : isFrontier\r\n        ? 'node-frontier'\r\n        : ''\r\n\r\n    const value = ((selectedAlgorithm === 'ASTAR' || selectedAlgorithm === 'GREED') && (fCost !== null)) ? fCost : ''\r\n\r\n    return <div \r\n            id={`node-${row}-${col}`}\r\n            className={`node ${nodeType}`}\r\n            onMouseDown={(!isFrontier && !isVisited && !isFinish && !isStart) ? () => onMouseDown(grid) : () => {}}\r\n            onMouseUp={mouseIsNotPressed}\r\n            onMouseEnter={(isMousePressed && !isWall && !isFrontier && !isVisited && !isFinish && !isStart) ? () => onMouseDown(grid) : () => {}}>{value}</div>\r\n}\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n    const node = state.grid[ownProps.row][ownProps.col];\r\n\r\n    return {\r\n        isStart:  node.isStart,\r\n        isFinish: node.isFinish,\r\n        isWall: node.isWall,\r\n        isFrontier: node.isFrontier,\r\n        isVisited: node.isVisited,\r\n        isPath: node.isPath,\r\n        isHead: node.isHead,\r\n        isBacktrack: node.isBacktrack,\r\n        isMousePressed: state.isMousePressed,\r\n        hCost: node.hCost,\r\n        gCost: node.gCost,\r\n        fCost: node.fCost,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        grid: state.grid\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch, ownProps) => {\r\n    return {\r\n        onMouseDown: (grid) => onMouseDown(ownProps.row, ownProps.col, dispatch, grid),\r\n        mouseIsNotPressed: () => dispatch(mouseIsNotPressed()),\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Node);","import React from 'react';\r\nimport Node from './Node';\r\nimport { connect } from 'react-redux';\r\nimport '../css/Grid.css';\r\nimport { generateNodeKey } from '../util/GridGenerationUtil'\r\n\r\nclass Grid extends React.Component {\r\n\r\n    render() {\r\n        const {grid} = this.props;\r\n\r\n        return (\r\n            <div className=\"grid\">\r\n                {\r\n                    grid.map((row, rowIndex) => {\r\n                        return (\r\n                            <div className=\"grid-row\" key={rowIndex}>\r\n                                {\r\n                                    row.map((col, colIndex) => {\r\n                                        return (<Node \r\n                                                    key={generateNodeKey(rowIndex, colIndex)}\r\n                                                    row={rowIndex} \r\n                                                    col={colIndex}/>);\r\n                                    })\r\n                                }\r\n                            </div>\r\n                        )\r\n                        \r\n                    })\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.grid,\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Grid);","import { gridDetails } from '../../constants';\r\nimport { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\n\r\nimport Queue from 'queue-fifo';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n  \r\nexport default class BFS {\r\n    constructor(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure, updateStatistics) {\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n        this.updateStatistics = updateStatistics;\r\n    }\r\n\r\n    async run(grid, queue) {\r\n        if(queue === null) {\r\n            queue = new Queue();\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            queue.enqueue(startNode);\r\n        }\r\n\r\n        while(!queue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = queue.dequeue();\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                await showPath(grid, this.togglePathNode, this.updateStatistics);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                if(!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) {\r\n\r\n                    if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                        await showPath(grid, this.togglePathNode, this.updateStatistics);\r\n                        return;\r\n                    }\r\n\r\n                    neighbour.isFrontier = true;\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n                    queue.enqueue(neighbour);\r\n                }\r\n            }\r\n            this.updateStatistics(grid);\r\n            await sleep(0);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(queue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n        \r\n    }\r\n}\r\n","import { gridDetails } from '../../constants';\r\nimport { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\nimport Stack from '@datastructures-js/stack';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n\r\nexport default class DFS {\r\n    constructor(toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, markBacktrackNodes, setDataStructure, updateStatistics) {\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.markHeadNode = markHeadNode;\r\n        this.unmarkHeadNode = unmarkHeadNode;\r\n        this.markBacktrackNodes = markBacktrackNodes;\r\n        this.setDataStructure = setDataStructure;\r\n        this.updateStatistics = updateStatistics;\r\n    }\r\n\r\n    async run(grid, stacks) {\r\n        let unvisitedStack = null;\r\n        let visitedStack = null;\r\n        let wasBacktracking = null;\r\n\r\n        if(stacks === null) {\r\n            unvisitedStack = new Stack();\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            unvisitedStack.push(startNode);\r\n\r\n            visitedStack = new Stack();\r\n            wasBacktracking = false;\r\n        } else {\r\n            unvisitedStack = stacks.unvisitedStack;\r\n            visitedStack = stacks.visitedStack;\r\n            wasBacktracking = stacks.wasBacktracking;\r\n        }\r\n\r\n        while(!unvisitedStack.isEmpty() && isAlgorithmRunning()) {\r\n            if(wasBacktracking) {\r\n                wasBacktracking = await this.backtrack(visitedStack, unvisitedStack, grid);\r\n                await sleep(20);\r\n                continue;\r\n            }\r\n\r\n\r\n            const currentNode = unvisitedStack.pop();\r\n            unvisitedStack = this.removeFromStack(unvisitedStack, currentNode);\r\n\r\n            currentNode.isVisited = true;\r\n            currentNode.isHead = true;\r\n            this.markHeadNode(currentNode.row, currentNode.col);\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.previousNode !== null) {\r\n                const { row, col } = currentNode.previousNode;\r\n                grid[row][col].isHead = false;\r\n                this.unmarkHeadNode(row, col);\r\n            }\r\n\r\n            if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                await showPath(grid, this.togglePathNode, this.updateStatistics);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = neighbours.length - 1; i >= 0; i--) {\r\n                const neighbour = neighbours[i];\r\n                if(!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) {\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    unvisitedStack.push(neighbour);\r\n                }\r\n            }\r\n\r\n            visitedStack.push(currentNode);\r\n\r\n            const validNeighbours = neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier)\r\n\r\n            if(validNeighbours.length === 0) {\r\n                // console.log(`deadend: ${currentNode.row}, ${currentNode.col}`)\r\n                // console.log(`unvisited: ${unvisitedStack.toArray().map(i => `(${i.row}, ${i.col}) `)}`)\r\n                // console.log(`visited: ${visitedStack.toArray().map(i => `(${i.row}, ${i.col}) `)}`)\r\n                currentNode.isHead = false;\r\n                this.unmarkHeadNode(currentNode.row, currentNode.col);\r\n                await sleep(20);\r\n                wasBacktracking = await this.backtrack(visitedStack, unvisitedStack, grid);\r\n               \r\n            }\r\n\r\n            this.updateStatistics(grid);\r\n            await sleep(40);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure({ unvisitedStack: unvisitedStack, visitedStack: visitedStack, wasBacktracking: wasBacktracking });\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    async backtrack(visitedStack, unvisitedStack, grid) {\r\n\r\n        let backtrackNodes = [];\r\n\r\n        while(!visitedStack.isEmpty() && !unvisitedStack.isEmpty() && isAlgorithmRunning()) {\r\n            const visitedNode = visitedStack.pop();\r\n\r\n            let neighbours = getNodeNeighbours(grid, visitedNode);\r\n            neighbours = neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier)\r\n            if(this.contains(neighbours, unvisitedStack.peek())) {\r\n                // console.log(`backtrack ${unvisitedStack.peek().row}, ${unvisitedStack.peek().col}`)\r\n                visitedStack.push(visitedNode);\r\n                this.markBacktrackNodes(backtrackNodes);\r\n                return;\r\n            } else {\r\n                backtrackNodes.push(visitedNode);\r\n            }   \r\n        }\r\n\r\n    }\r\n\r\n    contains(neighbours, target) {\r\n        for(let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            if(neighbour.row === target.row && neighbour.col === target.col) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n\r\n        return false;\r\n    }\r\n\r\n    removeFromStack(stack, target) {\r\n        const newStack = new Stack();\r\n        const tempStack = new Stack();\r\n\r\n        while(!stack.isEmpty()) {\r\n            const current = stack.pop();\r\n            if(current.row === target.row && current.col === target.col) {\r\n                continue;\r\n            }\r\n\r\n            tempStack.push(current);\r\n        }\r\n\r\n        while(!tempStack.isEmpty()) {\r\n            newStack.push(tempStack.pop());\r\n        }\r\n\r\n        return newStack;\r\n    }\r\n}\r\n","import { gridDetails } from '../../constants';\r\nimport { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath, updatePqueue } from '../AlgorithmUtil';\r\n\r\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n\r\nexport default class AStar {\r\n    constructor(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure, updateStatistics) {\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n        this.updateStatistics = updateStatistics;\r\n    }\r\n\r\n    async run(grid, pqueue) {\r\n        if(pqueue === null) {\r\n            pqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            startNode.gCost = 0;\r\n            startNode.fCost = startNode.gCost + startNode.hCost;\r\n            pqueue.enqueue(startNode);\r\n        }\r\n\r\n\r\n        while(!pqueue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = pqueue.dequeue().element;\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                await showPath(grid, this.togglePathNode, this.updateStatistics);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                if(!neighbour.isWall && !neighbour.isVisited) {\r\n\r\n                    if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                        await showPath(grid, this.togglePathNode, this.updateStatistics);\r\n                        return;\r\n                    }\r\n\r\n                    const tempG = currentNode.gCost + 1;\r\n                    const tempF = tempG + neighbour.hCost;\r\n                    if(neighbour.gCost !== null) {\r\n                        if(tempF < neighbour.fCost) {\r\n                            neighbour.gCost = tempG;\r\n                            neighbour.fCost = tempF;\r\n                            neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                            pqueue = updatePqueue(pqueue, neighbour);\r\n                        } \r\n                    } else {\r\n                        neighbour.gCost = tempG;\r\n                        neighbour.fCost = tempF;\r\n                        pqueue.enqueue(neighbour);\r\n                        neighbour.isFrontier = true;\r\n                        neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    }\r\n\r\n                    this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n                }\r\n            }\r\n\r\n            this.updateStatistics(grid);\r\n            await sleep(40);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(pqueue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n}","import { gridDetails } from '../../constants';\r\nimport { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath, updatePqueue } from '../AlgorithmUtil';\r\n\r\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n\r\nexport default class Greedy {\r\n    constructor(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure, updateStatistics) {\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n        this.updateStatistics = updateStatistics;\r\n    }\r\n\r\n    async run(grid, pqueue) {\r\n        if(pqueue === null) {\r\n            pqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            startNode.fCost = startNode.hCost;\r\n            pqueue.enqueue(startNode);\r\n        }\r\n\r\n\r\n        while(!pqueue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = pqueue.dequeue().element;\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                await showPath(grid, this.togglePathNode, this.updateStatistics);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                if(!neighbour.isWall && !neighbour.isVisited) {\r\n\r\n                    if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                        await showPath(grid, this.togglePathNode, this.updateStatistics);\r\n                        return;\r\n                    }\r\n\r\n                    if(!neighbour.isFrontier) {\r\n                        neighbour.isFrontier = true;\r\n                        neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                        this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n\r\n                        neighbour.fCost = neighbour.hCost;\r\n                        pqueue = updatePqueue(pqueue, neighbour);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            this.updateStatistics(grid);\r\n            await sleep(40);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(pqueue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n}","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Dropdown } from 'semantic-ui-react';\r\nimport { setSelectedAlgorithm } from '../actions';\r\n\r\nconst options = [\r\n    { key: 1, text: 'Breadth First Search (BFS)', value: 'BFS' },\r\n    { key: 2, text: 'Depth First Search (DFS)', value: 'DFS' },\r\n    { key: 3, text: 'A* Search', value: 'ASTAR' },\r\n    { key: 4, text: 'Greedy Best-First Search', value: 'GREED' }\r\n  ]\r\n\r\nclass SelectAlgorithmDropdown extends React.Component {\r\n    render() {\r\n        const selectedAlgorithmText = this.props.selectedAlgorithm === 'none' ? 'Select Algorithm' \r\n                                                                              : this.props.selectedAlgorithm === 'BFS'\r\n                                                                              ? 'Breadth First Search (BFS)'\r\n                                                                              : this.props.selectedAlgorithm === 'DFS'\r\n                                                                              ? 'Depth First Search (BFS)'\r\n                                                                              : this.props.selectedAlgorithm === 'ASTAR'\r\n                                                                              ? 'A* Search'\r\n                                                                              : this.props.selectedAlgorithm === 'GREED'\r\n                                                                              ? 'Greedy Best-First Search'\r\n                                                                              : 'Select Algorithm';\r\n\r\n        const disabled = this.props.algorithmStatus !== 'STOPPED';\r\n\r\n        return (\r\n            <Dropdown \r\n                fluid text={selectedAlgorithmText} \r\n                options={options} \r\n                simple item onChange={(event, data) => {this.props.onChange(data.value)}}\r\n                disabled={disabled}/>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        onChange: (algorithm) => {dispatch(setSelectedAlgorithm(algorithm))}\r\n    }\r\n}\r\n  \r\nexport default connect(mapStateToProps, mapDispatchToProps)(SelectAlgorithmDropdown)","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport BFS from '../util/algorithms/BFS';\r\nimport DFS from '../util/algorithms/DFS';\r\nimport AStar from '../util/algorithms/AStar';\r\nimport Greedy from '../util/algorithms/Greedy';\r\nimport { isAlgorithmRunning } from '../util/AlgorithmUtil'\r\nimport SelectAlgorithmDropdown from './SelectAlgorithmDropdown';\r\nimport { showInitialBoard, \r\n    runAlgorithm, \r\n    stopAlgorithm, \r\n    pauseAlgorithm, \r\n    completeAlgorithm, \r\n    toggleFrontierNode, \r\n    toggleVisitedNode, \r\n    togglePathNode, \r\n    resetDataStructure, \r\n    setDataStructure, \r\n    notShowingPath, \r\n    markHeadNode, \r\n    unmarkHeadNode, \r\n    resetBoardWithWalls, \r\n    markBacktrackNodes,\r\n    updateStatistics,\r\n    resetStatistics,\r\n    showStatistics,\r\n    hideStatistics,\r\n    generateRandomGrid } from '../actions';\r\n\r\nclass Menu extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.runSelectedAlgorithm = this.runSelectedAlgorithm.bind(this);\r\n        this.clearBoard = this.clearBoard.bind(this);\r\n\r\n    }\r\n\r\n    async runSelectedAlgorithm() {\r\n        const { selectedAlgorithm, \r\n                runAlgorithm, \r\n                pauseAlgorithm,\r\n                completeAlgorithm, \r\n                grid,\r\n                dataStructure,\r\n                toggleVisitedNode, \r\n                toggleFrontierNode, \r\n                togglePathNode,\r\n                setDataStructure,\r\n                isShowingPath,\r\n                markHeadNode,\r\n                unmarkHeadNode,\r\n                algorithmStatus,\r\n                markBacktrackNodes,\r\n                updateStatistics } = this.props;\r\n\r\n        if(selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') {\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmRunning()) {\r\n            pauseAlgorithm();\r\n            return;\r\n        }\r\n\r\n        runAlgorithm();\r\n\r\n        switch(selectedAlgorithm) {\r\n            case \"BFS\":\r\n                const bfs = new BFS(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure, updateStatistics);\r\n                await bfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"DFS\":\r\n                const dfs = new DFS(toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, markBacktrackNodes, setDataStructure, updateStatistics);\r\n                await dfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"ASTAR\":\r\n                const aStar = new AStar(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure, updateStatistics);\r\n                await aStar.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"GREED\":\r\n                const greedy = new Greedy(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure, updateStatistics);\r\n                await greedy.run(grid, dataStructure);\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        \r\n        if(isAlgorithmRunning()) {\r\n            completeAlgorithm();\r\n        }\r\n\r\n    }\r\n\r\n    clearBoard(clearWall) {\r\n        this.props.notShowingPath();\r\n        this.props.stopAlgorithm();\r\n        this.props.resetDataStructure();\r\n        this.props.resetStatistics(clearWall);\r\n\r\n        if(clearWall) {\r\n            this.props.showInitialBoard();\r\n        } else {\r\n            this.props.resetBoardWithWalls();\r\n        }\r\n        \r\n    }\r\n\r\n    render() {\r\n        const { selectedAlgorithm, algorithmStatus, isShowingPath, generateRandomGrid } = this.props;\r\n\r\n        const runButtonClass = (selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') ? \"active item\" : \"item\";\r\n\r\n        const canGenerateRandomGrid = algorithmStatus === 'STOPPED';\r\n\r\n        const randomGridButtonClass = canGenerateRandomGrid ? \"item\" : \"active item\"; \r\n\r\n        let runButtonText = \"Run\";\r\n\r\n        if((algorithmStatus === 'RUNNING' && isShowingPath) || algorithmStatus === 'COMPLETE') {\r\n            runButtonText = \"Complete\";\r\n        }\r\n\r\n        if(algorithmStatus === 'RUNNING' && !isShowingPath) {\r\n            runButtonText = \"Pause\";\r\n        }\r\n\r\n        return (\r\n            <div className=\"ui five item menu\">\r\n                <a  onClick={canGenerateRandomGrid ? generateRandomGrid : () => {}} className={randomGridButtonClass} >Generate Random Grid</a>\r\n                <SelectAlgorithmDropdown />\r\n                <a onClick={this.runSelectedAlgorithm} className={runButtonClass}>{runButtonText}!</a>\r\n                <a onClick={() => this.clearBoard(false)} className=\"item\">Clear Path</a>\r\n                <a onClick={() => this.clearBoard(true)} className=\"item\">Clear Board</a>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.grid,\r\n        dataStructure: state.dataStructure,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isShowingPath: state.isShowingPath,\r\n        statistics: state.statistics\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        showInitialBoard: () => dispatch(showInitialBoard()),\r\n        runAlgorithm: () => dispatch(runAlgorithm()),\r\n        stopAlgorithm: () => dispatch(stopAlgorithm()),\r\n        pauseAlgorithm: () => dispatch(pauseAlgorithm()),\r\n        completeAlgorithm: () => dispatch(completeAlgorithm()),\r\n        toggleVisitedNode: (row, col) => dispatch(toggleVisitedNode(row, col)),\r\n        toggleFrontierNode: (row, col) => dispatch(toggleFrontierNode(row, col)),\r\n        togglePathNode: (row, col) => dispatch(togglePathNode(row, col)),\r\n        resetDataStructure: () => dispatch(resetDataStructure()),\r\n        setDataStructure: (dataStructure) => dispatch(setDataStructure(dataStructure)),\r\n        notShowingPath: () => dispatch(notShowingPath()),\r\n        markHeadNode: (row, col) => dispatch(markHeadNode(row, col)),\r\n        unmarkHeadNode: (row, col) => dispatch(unmarkHeadNode(row, col)),\r\n        resetBoardWithWalls: () => dispatch(resetBoardWithWalls()),\r\n        markBacktrackNodes: (array) => dispatch(markBacktrackNodes(array)),\r\n        updateStatistics: (grid) => dispatch(updateStatistics(grid)),\r\n        resetStatistics: (resetWall) => dispatch(resetStatistics(resetWall)),\r\n        showStatistics: () => dispatch(resetStatistics()),\r\n        hideStatistics: () => dispatch(hideStatistics()),\r\n        generateRandomGrid: () => dispatch(generateRandomGrid())\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Menu);","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { updateStatistics, resetStatistics } from '../actions';\r\n\r\nclass InfoPanel extends React.Component {\r\n    render() {\r\n\r\n        const { show,\r\n                unvisited,\r\n                visited,\r\n                wall,\r\n                backtrack,\r\n                frontier,\r\n                path } = this.props.statistics;\r\n\r\n        const displayValue = (value) => (value === 0) ? \"\" : `${value} ` \r\n\r\n\r\n        return (\r\n            <div style={{width: \"85%\", margin: \"auto\", marginTop: \"2vh\"}}>\r\n                <div className=\"ui small eight statistics\">\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">\r\n                            <div className={`node node-start`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} />\r\n                        </div>\r\n                        <div class=\"label\">start</div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">\r\n                            <div className={`node node-finish`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} />\r\n                        </div>\r\n                        <div class=\"label\">end</div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(unvisited)} <div className={`node node-unvisited`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>unvisited</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(wall)} <div className={`node node-wall`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>wall</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(visited)} <div className={`node node-visited`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>visited</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(backtrack)} <div className={`node node-backtrack`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>backtrack</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(frontier)} <div className={`node node-frontier`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>frontier</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(path)} <div className={`node node-path`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>path</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n   \r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.grid,\r\n        dataStructure: state.dataStructure,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isShowingPath: state.isShowingPath,\r\n        statistics: state.statistics\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        updateStatistics: (grid) => dispatch(updateStatistics(grid)),\r\n        resetStatistics: () => dispatch(resetStatistics())\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(InfoPanel);","import React from 'react';\r\nimport Grid from './Grid';\r\nimport Menu from './Menu';\r\nimport InfoPanel from './InfoPanel';\r\nimport '../css/App.css';\r\n\r\nclass App extends React.Component {\r\n\r\n    render() {\r\n        return (\r\n            <div id=\"wrapper\" className=\"App\">\r\n                <Menu/>\r\n                <Grid />\r\n                <InfoPanel/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport { createStore } from 'redux';\r\nimport reducer from './reducers';\r\nimport App from './components/App';\r\nimport './css/App.css';\r\n\r\nexport const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\r\n\r\nReactDOM.render(<Provider store={store}><App /></Provider>, document.querySelector('#root'));\r\n"],"sourceRoot":""}