{"version":3,"sources":["media/bfs.gif","media/dfs.gif","media/astar.gif","media/greedy.gif","constants.js","actions/index.js","util/AlgorithmUtil.js","util/algorithms/BFS.js","util/algorithms/DFS.js","util/algorithms/AStar.js","util/algorithms/Greedy.js","util/GridGenerationUtil.js","reducers/index.js","components/Node.js","components/Grid.js","components/SelectAlgorithmModal/Carousel.js","components/SelectAlgorithmModal/SelectAlgorithmModal.js","components/Menu.js","components/InfoPanel.js","components/App.js","index.js"],"names":["module","exports","gridDetails","defaultStatistics","wall","unvisited","visited","backtrack","frontier","path","carouselCards","header","description","src","require","value","algorithmIndexMapping","BFS","DFS","ASTAR","GREED","dispatchMultipleActions","actions","i","length","calculateHCost","endNode","type","payload","row","col","TOTAL_ROW","TOTAL_COL","sleep","ms","Promise","resolve","setTimeout","getNodeNeighbours","state","node","neighbours","upNode","push","rightNode","downNode","leftNode","isAlgorithmRunning","store","getState","algorithmStatus","isAlgorithmPaused","isAlgorithmStopped","isShowingPath","showPath","togglePathNode","endRow","endCol","a","dispatch","finishNode","currentNode","stack","Stack","undefined","previousNode","isEmpty","pop","updatePqueue","pqueue","fCost","newPqueue","MinPriorityQueue","priority","inQueue","frontierNode","dequeue","element","enqueue","startNode","toggleVisitedNode","toggleFrontierNode","setDataStructure","this","grid","queue","Queue","isFrontier","isVisited","isFinish","neighbour","isWall","currentGrid","slice","isPath","markHeadNode","unmarkHeadNode","markBacktrackNodes","stacks","unvisitedStack","visitedStack","wasBacktracking","removeFromStack","isHead","filter","backtrackNodes","visitedNode","contains","peek","target","newStack","tempStack","current","rerunBacktrack","map","isBacktrack","AStar","gCost","hCost","tempG","tempF","Greedy","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","NodeFactory","isStart","distance","Infinity","generateInitalGrid","r","currentRow","c","generatePlainGrid","newGrid","newNode","generateToggleWallGrid","generateToggleFrontierGrid","generateMarkVisitedGrid","generateMarkPathGrid","generateGridWithWalls","generateMarkHeadGrid","generateUnmarkHeadGrid","generateMarkBacktrackGrid","array","generateNewStartGrid","newStart","oldStart","generateNewEndGrid","newEnd","oldEnd","generateNodeKey","toString","getStatistics","stats","leftover","generateRandomGrid","Math","random","calculateGridHCost","nodeRow","nodeCol","targetRow","targetCol","abs","generateRerunAlgorithmGrid","selectedAlgorithm","rerun","aStar","updatedGridWithHCost","greedy","updatedGridWithHCost1","initialMoveStartEnd","start","isStartMoving","end","isEndMoving","combineReducers","action","board","statistics","dataStructure","isMousePressed","moveStartEnd","Node","props","onMouseDownHandler","bind","onMouseEnterHandler","onMouseUpHandler","onMouseLeaveHandler","toggleWallNode","mouseIsPressed","startNodeMoving","endNodeMoving","onMouseDownActions","mouseIsNotPressed","setStartNode","setEndNode","rerunAlgorithm","nodeType","id","className","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","React","Component","connect","ownProps","isMoving","Grid","rowIndex","key","colIndex","Carousel","setSlide","plusSlides","updateDots","onSelect","initialIndex","slideIndex","index","dots","document","getElementsByClassName","replace","n","newSlideIndex","setState","close","setSelectedAlgorithm","currentCard","alt","height","width","onClick","style","textAlign","Button","positive","content","algorithm","SelectAlgorithmModal","open","closeConfigShow","closeOnEscape","closeOnDimmerClick","buttonText","isDisabled","triggerClass","Modal","trigger","onClose","marginBottom","size","Header","backgroundColor","color","Content","Menu","runSelectedAlgorithm","clearBoard","runAlgorithm","pauseAlgorithm","completeAlgorithm","window","scrollTo","bfs","run","dfs","clearWall","notShowingPath","stopAlgorithm","resetDataStructure","showInitialBoard","resetBoardWithWalls","clearBoardActions","runButtonClass","canGenerateRandomGrid","randomGridButtonClass","runButtonText","runButtonColor","InfoPanel","displayValue","margin","marginTop","class","border","borderRadius","App","createStore","reducer","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","render","querySelector"],"mappings":"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","file":"static/js/main.68b12367.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/bfs.4b09ebc5.gif\";","module.exports = __webpack_public_path__ + \"static/media/dfs.0c68fe6d.gif\";","module.exports = __webpack_public_path__ + \"static/media/astar.d0a045cb.gif\";","module.exports = __webpack_public_path__ + \"static/media/greedy.0e87f78d.gif\";","export const gridDetails = {\r\n    TOTAL_ROW: 21,\r\n    TOTAL_COL: 50,\r\n    START_NODE_ROW: 10,\r\n    START_NODE_COL: 5,\r\n    FINISH_NODE_ROW: 10,\r\n    FINISH_NODE_COL: 45 \r\n}\r\n\r\nexport const defaultStatistics = {\r\n    wall: 0,\r\n    unvisited: gridDetails.TOTAL_ROW * gridDetails.TOTAL_COL - 2,\r\n    visited: 0,\r\n    backtrack: 0,\r\n    frontier: 0,\r\n    path: 0\r\n}\r\n\r\nexport const wallRatio = 0.3;\r\n\r\nexport const carouselCards = [\r\n    {\r\n        header: \"Breath First Search (BFS)\",\r\n        description: \"Expands the shallowest unvisited nodes.\\n\\n  BFS guarantees the shortest path to the goal.\",\r\n        src: require(\"./media/bfs.gif\"),\r\n        value: \"BFS\"\r\n    },\r\n    {\r\n        header: \"Depth First Search (DFS)\",\r\n        description: \"Expands the deepest unvisited nodes.\\n\\n  DFS does not guarantee the shortest path to the goal.\",\r\n        src: require(\"./media/dfs.gif\"),\r\n        value: \"DFS\"\r\n    },\r\n    {\r\n        header: \"A* Search\",\r\n        description: `Expands unvisited nodes with the lowest estimated cost of the cheapest path from the start to the goal through the node.\\n\\n   A* guarantees the shortest path to the goal.`,\r\n        src: require(\"./media/astar.gif\"),\r\n        value: \"ASTAR\"\r\n    },\r\n    {\r\n        header: \"Greedy Best-First Search\",\r\n        description: `Expands unvisited nodes that are estimated to be closest to the goal.\\n\\n  Greedy Search does not guarantee the shortest path to the goal.`,\r\n        src: require(\"./media/greedy.gif\"),\r\n        value: \"GREED\"\r\n    },\r\n]\r\n\r\nexport const algorithmIndexMapping = {\r\n    BFS: 0,\r\n    DFS: 1,\r\n    ASTAR: 2,\r\n    GREED: 3\r\n}","export const toggleWallNode = (row, col) => {\r\n    return {\r\n        type: 'TOOGLE_WALL_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const mouseIsPressed = () => {\r\n    return { type: 'PRESSED'};\r\n}\r\n\r\nexport const mouseIsNotPressed = () => {\r\n    return { type: 'NOT_PRESSED'};\r\n}\r\n\r\nexport const dispatchMultipleActions = (actions) => {\r\n    for(let i = 0; i < actions.length; i++) {\r\n        actions[i]();\r\n    }\r\n}\r\n\r\nexport const runAlgorithm = () => {\r\n    return { type: 'RUN_ALGORITHM'};\r\n}\r\n\r\nexport const stopAlgorithm = () => {\r\n    return { type: 'STOP_ALGORITHM'};\r\n}\r\n\r\nexport const showInitialBoard = () => {\r\n    return { type: 'SHOW_INITIAL_BOARD' };\r\n}\r\n\r\nexport const resetBoardWithWalls = () => {\r\n    return { type: 'RESET_BOARD_WITH_WALLS' };\r\n}\r\n\r\nexport const generateRandomGrid = (endNde) => {\r\n    return { type: 'GENERATE_RANDOM_GRID' };\r\n}\r\n\r\nexport const pauseAlgorithm = () => {\r\n    return { type: 'PAUSE_ALGORITHM'};\r\n}\r\n\r\nexport const completeAlgorithm = () => {\r\n    return { type: 'COMPLETE_ALGORITHM'};\r\n}\r\n\r\nexport const toggleFrontierNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_FRONTIER_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const toggleVisitedNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_VISITED_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const togglePathNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_PATH_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const setSelectedAlgorithm = (algorithmName) => {\r\n    return {\r\n        type: algorithmName\r\n    }\r\n}\r\n\r\nexport const resetDataStructure = () => {\r\n    return { type: 'RESET_DATA_STRUCTURE' }\r\n}\r\n\r\nexport const setDataStructure = (dataStructure) => {\r\n    return {\r\n        type: 'SET_DATA_STRUCTURE',\r\n        payload: dataStructure\r\n    }\r\n}\r\n\r\nexport const showingPath = () => {\r\n    return { type: 'SHOWING_PATH' };\r\n}\r\n\r\nexport const notShowingPath = () => {\r\n    return { type: 'NOT_SHOWING_PATH' };\r\n}\r\n\r\nexport const markHeadNode = (row, col) => {\r\n    return {\r\n        type: 'MARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const unmarkHeadNode = (row, col) => {\r\n    return {\r\n        type: 'UNMARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const markBacktrackNodes = (array) => {\r\n    return  {\r\n        type: 'MARK_BACKTRACK_NODE',\r\n        payload: { array }\r\n    }\r\n}\r\n\r\nexport const startNodeMoving = (isMoving) => {\r\n    return { type: (isMoving ? 'START_NODE_MOVING' : 'START_NODE_NOT_MOVING') };\r\n}\r\n\r\nexport const startNodeNotMoving = () => {\r\n    return { type: 'START_NODE_NOT_MOVING' };\r\n}\r\n\r\nexport const endNodeMoving = (isMoving) => {\r\n    return { type: (isMoving? 'END_NODE_MOVING' : 'END_NODE_NOT_MOVING') };\r\n}\r\n\r\nexport const endNodeNotMoving = () => {\r\n    return { type: 'END_NODE_NOT_MOVING' };\r\n}\r\n\r\nexport const setStartNode = (newStart, oldStart) => {\r\n    return {\r\n        type: 'SET_START_NODE',\r\n        payload: { newStart, oldStart }\r\n    }\r\n}\r\n\r\nexport const setEndNode = (newEnd, oldEnd) => {\r\n    return {\r\n        type: 'SET_END_NODE',\r\n        payload: { newEnd, oldEnd }\r\n    }\r\n}\r\n\r\nexport const calculateHCost = (endNode) => {\r\n    return { \r\n        type: 'CALCULATE_HCOST',\r\n        payload: {\r\n            row: endNode.row,\r\n            col: endNode.col\r\n        }\r\n    };\r\n}\r\n\r\nexport const rerunAlgorithm = (selectedAlgorithm, startNode, endNode) => {\r\n    return {\r\n        type: 'RERUN_ALGORITHM',\r\n        payload: { selectedAlgorithm, startNode, endNode }\r\n    }\r\n}","import { gridDetails } from '../constants';\r\nimport { store } from '../index';\r\nimport Stack from '@datastructures-js/stack';\r\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\nimport { showingPath, notShowingPath } from '../actions';\r\n\r\nconst { TOTAL_ROW, TOTAL_COL } = gridDetails;\r\n\r\nexport function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nexport const getNodeNeighbours = (state, node) => {\r\n    let neighbours = [];\r\n\r\n    if(node.row > 0) {\r\n        const upNode = state[node.row - 1][node.col];\r\n        neighbours.push(upNode);\r\n    }\r\n\r\n    if(node.col < (TOTAL_COL - 1)) {\r\n        const rightNode = state[node.row][node.col + 1];\r\n        neighbours.push(rightNode);\r\n    }\r\n\r\n    if(node.row < (TOTAL_ROW - 1)) {\r\n        const downNode = state[node.row + 1][node.col];\r\n        neighbours.push(downNode);\r\n    }\r\n\r\n    if(node.col > 0) {\r\n        const leftNode = state[node.row][node.col - 1];\r\n        neighbours.push(leftNode);\r\n    }\r\n\r\n    return neighbours;\r\n}\r\n\r\nexport const isAlgorithmRunning = () => {\r\n    return (store.getState().algorithmStatus === 'RUNNING');\r\n}\r\n\r\nexport const isAlgorithmPaused = () => {\r\n    return (store.getState().algorithmStatus === 'PAUSED');\r\n}\r\n\r\nexport const isAlgorithmStopped = () => {\r\n    return (store.getState().algorithmStatus === 'STOPPED');\r\n}\r\n\r\nconst isShowingPath = () => {\r\n    return store.getState().isShowingPath;\r\n}\r\n\r\nexport async function showPath(state, togglePathNode, endRow, endCol) {\r\n    store.dispatch(showingPath());\r\n\r\n    const finishNode = state[endRow][endCol];\r\n    let currentNode = finishNode;\r\n    const stack = new Stack();\r\n    while(currentNode !== undefined) {\r\n        stack.push(currentNode);\r\n\r\n        if(!currentNode.previousNode) {\r\n            break;\r\n        }\r\n        currentNode = state[currentNode.previousNode.row][currentNode.previousNode.col];\r\n    }\r\n\r\n    while(!stack.isEmpty()) {\r\n        if(isAlgorithmStopped() || !isShowingPath()) {\r\n            return;\r\n        }\r\n\r\n        let node = stack.pop();\r\n        togglePathNode(node.row, node.col);\r\n        await sleep(20);\r\n    }\r\n\r\n    store.dispatch(notShowingPath());\r\n}\r\n\r\nexport const calculateMahattanDistance = (nodeRow, nodeCol, targetRow, targetCol) => {\r\n    return Math.abs(nodeRow - targetRow) + Math.abs(nodeCol - targetCol);\r\n}\r\n\r\nexport const updatePqueue = (pqueue, node) => {\r\n    const { row, col, fCost } = node;\r\n    const newPqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n    let inQueue = false;\r\n\r\n    while(!pqueue.isEmpty()) {\r\n        const frontierNode = pqueue.dequeue().element;\r\n\r\n        if(frontierNode.row === row && frontierNode.col === col) {\r\n            inQueue = true;\r\n            if(frontierNode.fCost <= fCost) {\r\n                newPqueue.enqueue(frontierNode);\r\n            } else {    \r\n                newPqueue.enqueue(node);\r\n            }\r\n        } else {\r\n            newPqueue.enqueue(frontierNode);\r\n        }\r\n    }\r\n\r\n    if(!inQueue) {\r\n        newPqueue.enqueue(node);\r\n    }\r\n\r\n    return newPqueue;\r\n}","import { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\nimport Queue from 'queue-fifo';\r\n  \r\nexport default class BFS {\r\n    constructor(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure) {\r\n        this.startNode = startNode;\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, queue) {\r\n        if(queue === null) {\r\n            queue = new Queue();\r\n            const startNode = grid[this.startNode.row][this.startNode.col];\r\n            queue.enqueue(startNode);\r\n        }\r\n\r\n        while(!queue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = queue.dequeue();\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.isFinish) {\r\n                await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                // if(neighbour.isFinish) {\r\n                //     await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                //     return;\r\n                // }\r\n                if((!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) || neighbour.isFinish) {\r\n                    neighbour.isFrontier = true;\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n                    queue.enqueue(neighbour);\r\n                }\r\n            }\r\n            await sleep(30);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(queue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n        \r\n    }\r\n\r\n    rerun(currentGrid) {\r\n        const grid = currentGrid.slice();\r\n\r\n        const queue = new Queue();\r\n        const startNode = grid[this.startNode.row][this.startNode.col];\r\n        queue.enqueue(startNode);\r\n\r\n        while(!queue.isEmpty()) {\r\n            const currentNode = queue.dequeue();\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n\r\n            if(currentNode.isFinish) {\r\n\r\n                let node = currentNode;\r\n                while(node !== undefined) {\r\n                    node.isPath = true;\r\n                    if(!node.previousNode) {\r\n                        break;\r\n                    }\r\n                    node = grid[node.previousNode.row][node.previousNode.col]\r\n                }\r\n\r\n\r\n                return grid;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                if((!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) || neighbour.isFinish) {\r\n                    neighbour.isFrontier = true;\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    queue.enqueue(neighbour);\r\n                }\r\n            }\r\n        }\r\n\r\n        return grid;\r\n    }\r\n}\r\n","import { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\nimport Stack from '@datastructures-js/stack';\r\n\r\nexport default class DFS {\r\n    constructor(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, markBacktrackNodes, setDataStructure) {\r\n        this.startNode = startNode;\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.markHeadNode = markHeadNode;\r\n        this.unmarkHeadNode = unmarkHeadNode;\r\n        this.markBacktrackNodes = markBacktrackNodes;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, stacks) {\r\n        let unvisitedStack = null;\r\n        let visitedStack = null;\r\n        let wasBacktracking = null;\r\n\r\n        if(stacks === null) {\r\n            unvisitedStack = new Stack();\r\n            const startNode = grid[this.startNode.row][this.startNode.col];\r\n            unvisitedStack.push(startNode);\r\n\r\n            visitedStack = new Stack();\r\n            wasBacktracking = false;\r\n        } else {\r\n            unvisitedStack = stacks.unvisitedStack;\r\n            visitedStack = stacks.visitedStack;\r\n            wasBacktracking = stacks.wasBacktracking;\r\n        }\r\n\r\n        while(!unvisitedStack.isEmpty() && isAlgorithmRunning()) {\r\n            if(wasBacktracking) {\r\n                wasBacktracking = await this.backtrack(visitedStack, unvisitedStack, grid);\r\n                await sleep(20);\r\n                continue;\r\n            }\r\n\r\n\r\n            const currentNode = unvisitedStack.pop();\r\n            unvisitedStack = this.removeFromStack(unvisitedStack, currentNode);\r\n\r\n            currentNode.isVisited = true;\r\n            currentNode.isHead = true;\r\n            this.markHeadNode(currentNode.row, currentNode.col);\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.previousNode !== null) {\r\n                const { row, col } = currentNode.previousNode;\r\n                grid[row][col].isHead = false;\r\n                this.unmarkHeadNode(row, col);\r\n            }\r\n\r\n            if(currentNode.isFinish) {\r\n                await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = neighbours.length - 1; i >= 0; i--) {\r\n                const neighbour = neighbours[i];\r\n                if((!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) || neighbour.isFinish) {\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    unvisitedStack.push(neighbour);\r\n                }\r\n            }\r\n\r\n            visitedStack.push(currentNode);\r\n\r\n            const validNeighbours = neighbours.filter(neighbour => ((!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) || neighbour.isFinish))\r\n\r\n            if(validNeighbours.length === 0) {\r\n                currentNode.isHead = false;\r\n                this.unmarkHeadNode(currentNode.row, currentNode.col);\r\n                await sleep(20);\r\n                wasBacktracking = await this.backtrack(visitedStack, unvisitedStack, grid);\r\n               \r\n            }\r\n\r\n            await sleep(40);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure({ unvisitedStack: unvisitedStack, visitedStack: visitedStack, wasBacktracking: wasBacktracking });\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    async backtrack(visitedStack, unvisitedStack, grid) {\r\n\r\n        let backtrackNodes = [];\r\n\r\n        while(!visitedStack.isEmpty() && !unvisitedStack.isEmpty() && isAlgorithmRunning()) {\r\n            const visitedNode = visitedStack.pop();\r\n\r\n            let neighbours = getNodeNeighbours(grid, visitedNode);\r\n            neighbours = neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier)\r\n            if(this.contains(neighbours, unvisitedStack.peek())) {\r\n                visitedStack.push(visitedNode);\r\n                this.markBacktrackNodes(backtrackNodes);\r\n                return;\r\n            } else {\r\n                backtrackNodes.push(visitedNode);\r\n            }   \r\n        }\r\n\r\n    }\r\n\r\n    contains(neighbours, target) {\r\n        for(let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            if(neighbour.row === target.row && neighbour.col === target.col) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n\r\n        return false;\r\n    }\r\n\r\n    removeFromStack(stack, target) {\r\n        const newStack = new Stack();\r\n        const tempStack = new Stack();\r\n\r\n        while(!stack.isEmpty()) {\r\n            const current = stack.pop();\r\n            if(current.row === target.row && current.col === target.col) {\r\n                continue;\r\n            }\r\n\r\n            tempStack.push(current);\r\n        }\r\n\r\n        while(!tempStack.isEmpty()) {\r\n            newStack.push(tempStack.pop());\r\n        }\r\n\r\n        return newStack;\r\n    }\r\n\r\n    rerun(currentGrid) {\r\n        const grid = currentGrid.slice();\r\n\r\n        let unvisitedStack = new Stack();\r\n        const startNode = grid[this.startNode.row][this.startNode.col];\r\n        unvisitedStack.push(startNode);\r\n\r\n        const visitedStack = new Stack();\r\n\r\n        while(!unvisitedStack.isEmpty()) {\r\n            const currentNode = unvisitedStack.pop();\r\n            unvisitedStack = this.removeFromStack(unvisitedStack, currentNode);\r\n\r\n            currentNode.isVisited = true;\r\n            currentNode.isHead = true;\r\n\r\n            if(currentNode.previousNode !== null) {\r\n                const { row, col } = currentNode.previousNode;\r\n                grid[row][col].isHead = false;\r\n            }\r\n\r\n            if(currentNode.isFinish) {\r\n                let node = currentNode;\r\n                while(node !== undefined) {\r\n                    node.isPath = true;\r\n                    if(!node.previousNode) {\r\n                        break;\r\n                    }\r\n                    node = grid[node.previousNode.row][node.previousNode.col]\r\n                }\r\n                return grid;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = neighbours.length - 1; i >= 0; i--) {\r\n                const neighbour = neighbours[i];\r\n                if((!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) || neighbour.isFinish) {\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    unvisitedStack.push(neighbour);\r\n                }\r\n            }\r\n\r\n            visitedStack.push(currentNode);\r\n\r\n            const validNeighbours = neighbours.filter(neighbour => ((!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) || neighbour.isFinish))\r\n\r\n            if(validNeighbours.length === 0) {\r\n                currentNode.isHead = false;\r\n                this.rerunBacktrack(visitedStack, unvisitedStack, grid);\r\n               \r\n            }\r\n\r\n        }\r\n\r\n        return grid;\r\n    }\r\n\r\n    rerunBacktrack(visitedStack, unvisitedStack, grid) {\r\n\r\n        let backtrackNodes = [];\r\n\r\n        while(!visitedStack.isEmpty() && !unvisitedStack.isEmpty()) {\r\n            const visitedNode = visitedStack.pop();\r\n\r\n            let neighbours = getNodeNeighbours(grid, visitedNode);\r\n            neighbours = neighbours.filter(neighbour => ((!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) || neighbour.isFinish))\r\n            if(this.contains(neighbours, unvisitedStack.peek())) {\r\n                visitedStack.push(visitedNode);\r\n                backtrackNodes.map(node => node.isBacktrack = true);\r\n                return;\r\n            } else {\r\n                backtrackNodes.push(visitedNode);\r\n            }   \r\n        }\r\n\r\n    }\r\n}\r\n","import { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath, updatePqueue } from '../AlgorithmUtil';\r\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\nexport default class AStar {\r\n    constructor(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure) {\r\n        this.startNode = startNode;\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, pqueue) {\r\n        if(pqueue === null) {\r\n            pqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n            const startNode = grid[this.startNode.row][this.startNode.col];\r\n            startNode.gCost = 0;\r\n            startNode.fCost = startNode.gCost + startNode.hCost;\r\n            pqueue.enqueue(startNode);\r\n        }\r\n\r\n\r\n        while(!pqueue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = pqueue.dequeue().element;\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.isFinish) {\r\n                await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                \r\n                if((!neighbour.isWall && !neighbour.isVisited) || neighbour.isFinish) {\r\n                    const tempG = currentNode.gCost + 1;\r\n                    const tempF = tempG + neighbour.hCost;\r\n                    if(neighbour.gCost !== null) {\r\n                        if(tempF < neighbour.fCost) {\r\n                            neighbour.gCost = tempG;\r\n                            neighbour.fCost = tempF;\r\n                            neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                            pqueue = updatePqueue(pqueue, neighbour);\r\n                        } \r\n                    } else {\r\n                        neighbour.gCost = tempG;\r\n                        neighbour.fCost = tempF;\r\n                        pqueue.enqueue(neighbour);\r\n                        neighbour.isFrontier = true;\r\n                        neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    }\r\n\r\n                    this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n                }\r\n            }\r\n\r\n            await sleep(40);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(pqueue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    rerun(currentGrid) {\r\n        const grid = currentGrid.slice();\r\n\r\n        let pqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n        const startNode = grid[this.startNode.row][this.startNode.col];\r\n        startNode.gCost = 0;\r\n        startNode.fCost = startNode.gCost + startNode.hCost;\r\n        pqueue.enqueue(startNode);\r\n\r\n        while(!pqueue.isEmpty()) {\r\n            const currentNode = pqueue.dequeue().element;\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n\r\n            if(currentNode.isFinish) {\r\n                let node = currentNode;\r\n                while(node !== undefined) {\r\n                    node.isPath = true;\r\n                    if(!node.previousNode) {\r\n                        break;\r\n                    }\r\n                    node = grid[node.previousNode.row][node.previousNode.col]\r\n                }\r\n                return grid;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                \r\n                if((!neighbour.isWall && !neighbour.isVisited) || neighbour.isFinish) {\r\n                    const tempG = currentNode.gCost + 1;\r\n                    const tempF = tempG + neighbour.hCost;\r\n                    if(neighbour.gCost !== null) {\r\n                        if(tempF < neighbour.fCost) {\r\n                            neighbour.gCost = tempG;\r\n                            neighbour.fCost = tempF;\r\n                            neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                            pqueue = updatePqueue(pqueue, neighbour);\r\n                        } \r\n                    } else {\r\n                        neighbour.gCost = tempG;\r\n                        neighbour.fCost = tempF;\r\n                        pqueue.enqueue(neighbour);\r\n                        neighbour.isFrontier = true;\r\n                        neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return grid;\r\n    }\r\n}","import { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath, updatePqueue } from '../AlgorithmUtil';\r\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\nexport default class Greedy {\r\n    constructor(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure) {\r\n        this.startNode = startNode;\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, pqueue) {\r\n        if(pqueue === null) {\r\n            pqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n            const startNode = grid[this.startNode.row][this.startNode.col];\r\n            startNode.fCost = startNode.hCost;\r\n            pqueue.enqueue(startNode);\r\n        }\r\n\r\n\r\n        while(!pqueue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = pqueue.dequeue().element;\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.isFinish) {\r\n                await showPath(grid, this.togglePathNode, currentNode.row, currentNode.col);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                if((!neighbour.isWall && !neighbour.isVisited) || neighbour.isFinish) {\r\n\r\n                    if(!neighbour.isFrontier) {\r\n                        neighbour.isFrontier = true;\r\n                        neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                        this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n\r\n                        neighbour.fCost = neighbour.hCost;\r\n                        pqueue = updatePqueue(pqueue, neighbour);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            await sleep(40);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(pqueue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    rerun(grid) {\r\n        let pqueue = new MinPriorityQueue({ priority: (node) => node.fCost });\r\n        const startNode = grid[this.startNode.row][this.startNode.col];\r\n        startNode.fCost = startNode.hCost;\r\n        pqueue.enqueue(startNode);\r\n\r\n        while(!pqueue.isEmpty()) {\r\n            const currentNode = pqueue.dequeue().element;\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n\r\n            if(currentNode.isFinish) {\r\n                let node = currentNode;\r\n                while(node !== undefined) {\r\n                    node.isPath = true;\r\n                    if(!node.previousNode) {\r\n                        break;\r\n                    }\r\n                    node = grid[node.previousNode.row][node.previousNode.col]\r\n                }\r\n                return grid;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                if((!neighbour.isWall && !neighbour.isVisited) || neighbour.isFinish) {\r\n\r\n                    if(!neighbour.isFrontier) {\r\n                        neighbour.isFrontier = true;\r\n                        neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n\r\n                        neighbour.fCost = neighbour.hCost;\r\n                        pqueue = updatePqueue(pqueue, neighbour);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n       return grid;\r\n    }\r\n}","import { gridDetails, defaultStatistics, wallRatio } from '../constants';\r\nimport { calculateMahattanDistance } from './AlgorithmUtil';\r\nimport BFS from './algorithms/BFS';\r\nimport DFS from './algorithms/DFS';\r\nimport AStar from './algorithms/AStar';\r\nimport Greedy from './algorithms/Greedy';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL, TOTAL_ROW, TOTAL_COL} = gridDetails;\r\n\r\nfunction NodeFactory(row, col) {\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        isFrontier: false,\r\n        isHead: false,\r\n        isBacktrack: false,\r\n        previousNode: null,\r\n        isPath: false,\r\n        hCost: null,\r\n        gCost: null,\r\n        fCost: null\r\n      };\r\n}\r\n\r\nexport function generateInitalGrid() {\r\n    const grid = [];\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        const currentRow = [];\r\n\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            currentRow.push(NodeFactory(r, c));\r\n        }\r\n\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    return grid;\r\n}\r\n\r\nexport function generatePlainGrid(currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n\r\n            const newNode = NodeFactory(r, c);\r\n\r\n            newNode.isStart = node.isStart;\r\n            newNode.isFinish = node.isFinish;\r\n\r\n            newGrid[r][c] = newNode;\r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateToggleWallGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateToggleFrontierGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isFrontier: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkVisitedGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isVisited: true,\r\n        isFrontier: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkPathGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isPath: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateGridWithWalls(currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n\r\n            const newNode = NodeFactory(r, c);\r\n\r\n            newNode.isStart = node.isStart;\r\n            newNode.isFinish = node.isFinish;\r\n            newNode.isWall = node.isWall;\r\n\r\n            newGrid[r][c] = newNode;\r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateUnmarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkBacktrackGrid(array, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let i = 0; i < array.length; i++) {\r\n        const { row, col } = array[i];\r\n        const node = newGrid[row][col];\r\n\r\n        const newNode = {\r\n            ...node,\r\n            isBacktrack: true\r\n        };\r\n        newGrid[row][col] = newNode;\r\n    }\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateNewStartGrid(newStart, oldStart, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    newGrid[oldStart.row][oldStart.col].isStart = false;\r\n    newGrid[newStart.row][newStart.col].isStart = true;\r\n    return newGrid;\r\n}\r\n\r\nexport function generateNewEndGrid(newEnd, oldEnd, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    newGrid[oldEnd.row][oldEnd.col].isFinish = false;\r\n    newGrid[newEnd.row][newEnd.col].isFinish = true;\r\n    return newGrid;\r\n}\r\n\r\nexport function generateNodeKey(row, col) {\r\n    return (row * TOTAL_ROW + col).toString();\r\n}\r\n\r\nexport function getStatistics(grid) {\r\n    const stats = { ...defaultStatistics };\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = grid[r][c];\r\n\r\n            if(node.isWall && !node.isFinish && !node.isStart) {\r\n                stats.wall++;\r\n            }\r\n\r\n            if(node.isVisited) {\r\n                stats.visited++;\r\n            }\r\n\r\n            if(node.isBacktrack) {\r\n                stats.backtrack++;\r\n            }\r\n\r\n            if(node.isFrontier) {\r\n                stats.frontier++;\r\n            }\r\n            \r\n            if(node.isPath) {\r\n                stats.path++;\r\n            }\r\n        }\r\n    }\r\n\r\n    const leftover = (TOTAL_ROW * TOTAL_COL - 2) - stats.wall - stats.visited - stats.frontier;\r\n    stats.unvisited = leftover <= 0 ? 0 : leftover;\r\n\r\n    return stats;\r\n}\r\n\r\nfunction setAsWall() {\r\n    return Math.random() < wallRatio;\r\n}\r\n\r\nexport function generateRandomGrid(currentGrid) {\r\n    const newGrid = generatePlainGrid(currentGrid);\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n            node.hCost = null;\r\n\r\n            if(!node.isStart && !node.isFinish) {\r\n                node.isWall = setAsWall();\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function calculateGridHCost(currentGrid, endRow, endCol) {\r\n    const newGrid = currentGrid.slice();\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const node = newGrid[r][c];\r\n            node.hCost = calculateMahattanDistance(r, c, endRow, endCol);\r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateRerunAlgorithmGrid(currentGrid, selectedAlgorithm, startNode, endNode) {\r\n    switch(selectedAlgorithm) {\r\n        case 'BFS':\r\n            const bfs = new BFS(startNode);\r\n            return bfs.rerun(generateGridWithWalls(currentGrid));\r\n\r\n        case 'DFS':\r\n            const dfs = new DFS(startNode);\r\n            return dfs.rerun(generateGridWithWalls(currentGrid));\r\n\r\n        case 'ASTAR':\r\n            const aStar = new AStar(startNode);\r\n            const updatedGridWithHCost = calculateGridHCost(generateGridWithWalls(currentGrid), endNode.row, endNode.col)\r\n            return aStar.rerun(updatedGridWithHCost);\r\n\r\n\r\n        case 'GREED':\r\n            const greedy = new Greedy(startNode);\r\n            const updatedGridWithHCost1 = calculateGridHCost(generateGridWithWalls(currentGrid), endNode.row, endNode.col)\r\n            return greedy.rerun(updatedGridWithHCost1);\r\n\r\n        default:\r\n            return currentGrid;\r\n    }\r\n}","import { combineReducers } from 'redux';\r\nimport { defaultStatistics } from '../constants';\r\nimport { gridDetails } from '../constants';\r\nimport { \r\n    generateInitalGrid,\r\n    generateToggleWallGrid, \r\n    generateToggleFrontierGrid, \r\n    generateMarkVisitedGrid, \r\n    generateMarkPathGrid, \r\n    generateGridWithWalls, \r\n    generateMarkHeadGrid, \r\n    generateUnmarkHeadGrid, \r\n    generateMarkBacktrackGrid, \r\n    getStatistics,\r\n    generateRandomGrid,\r\n    generatePlainGrid,\r\n    generateNewStartGrid,\r\n    generateNewEndGrid,\r\n    calculateGridHCost,\r\n    generateRerunAlgorithmGrid\r\n } from '../util/GridGenerationUtil';\r\n\r\nconst boardReducer = (state={ grid: generateInitalGrid(), statistics: defaultStatistics }, action) => {\r\n    let newGrid = state.grid;\r\n    let newStatistics = state.statistics;\r\n\r\n    switch(action.type) {\r\n        case 'TOOGLE_WALL_NODE':\r\n            newGrid = generateToggleWallGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'TOGGLE_FRONTIER_NDOE':\r\n            newGrid = generateToggleFrontierGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n            \r\n        case 'TOGGLE_VISITED_NODE':\r\n            newGrid = generateMarkVisitedGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'TOGGLE_PATH_NODE':\r\n            newGrid = generateMarkPathGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'SHOW_INITIAL_BOARD':\r\n            newGrid = generatePlainGrid(state.grid);\r\n            break;\r\n\r\n        case 'RESET_BOARD_WITH_WALLS':\r\n            newGrid = generateGridWithWalls(state.grid);\r\n            break;\r\n\r\n        case 'MARK_HEAD_NODE':\r\n            newGrid = generateMarkHeadGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'UNMARK_HEAD_NODE':\r\n            newGrid = generateUnmarkHeadGrid(action.payload.row, action.payload.col, state.grid);\r\n            break;\r\n\r\n        case 'MARK_BACKTRACK_NODE':\r\n            newGrid = generateMarkBacktrackGrid(action.payload.array, state.grid);\r\n            break;\r\n\r\n        case 'GENERATE_RANDOM_GRID':\r\n            newGrid = generateRandomGrid(state.grid);\r\n            break;\r\n\r\n        case 'SET_START_NODE':\r\n            newGrid = generateNewStartGrid(action.payload.newStart, action.payload.oldStart, state.grid);\r\n            break;\r\n\r\n        case 'SET_END_NODE':\r\n            newGrid = generateNewEndGrid(action.payload.newEnd, action.payload.oldEnd, state.grid);\r\n            break;\r\n\r\n        case 'CALCULATE_HCOST':\r\n            newGrid = calculateGridHCost(state.grid, action.payload.row, action.payload.col);\r\n            break;\r\n\r\n        case 'RERUN_ALGORITHM':\r\n            newGrid = generateRerunAlgorithmGrid(state.grid, action.payload.selectedAlgorithm, action.payload.startNode, action.payload.endNode);\r\n            break;\r\n\r\n        default:\r\n            break;\r\n    }\r\n\r\n    newStatistics = getStatistics(newGrid);\r\n    return { grid: newGrid, statistics: newStatistics };\r\n}\r\n\r\nconst dataStructureReducer = (state=null, action) => {\r\n    switch(action.type) {\r\n        case 'RESET_DATA_STRUCTURE':\r\n            return null;\r\n\r\n        case 'SET_DATA_STRUCTURE':\r\n            return action.payload;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst mousePressedReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'PRESSED':\r\n            return true;\r\n\r\n        case 'NOT_PRESSED':\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst selectAlgorithmReducer = (state='none', action) => {\r\n    switch(action.type) {\r\n        case 'BFS':\r\n            return 'BFS';\r\n\r\n        case 'DFS':\r\n            return 'DFS';\r\n\r\n        case 'ASTAR':\r\n            return 'ASTAR';\r\n\r\n        case 'GREED':\r\n            return 'GREED';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst algorithmStatusReducer = (state='STOPPED', action) => {\r\n    switch(action.type) {\r\n        case 'RUN_ALGORITHM':\r\n            return 'RUNNING';\r\n\r\n        case 'STOP_ALGORITHM':\r\n            return 'STOPPED';\r\n\r\n        case 'PAUSE_ALGORITHM':\r\n            return 'PAUSED';\r\n\r\n        case 'COMPLETE_ALGORITHM':\r\n            return 'COMPLETE';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst isShowingPathReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'SHOWING_PATH':\r\n            return true;\r\n\r\n        case 'NOT_SHOWING_PATH':\r\n            return false;\r\n        \r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst initialMoveStartEnd = {\r\n    start: { row: gridDetails.START_NODE_ROW, col: gridDetails.START_NODE_COL },\r\n    isStartMoving: false,\r\n    end: { row: gridDetails.FINISH_NODE_ROW, col: gridDetails.FINISH_NODE_COL },\r\n    isEndMoving: false\r\n}\r\n\r\nconst moveStartEndReducer = (state=initialMoveStartEnd, action) => {\r\n    switch(action.type) {\r\n        case 'START_NODE_MOVING':\r\n            return { ...state, isStartMoving: true};\r\n\r\n        case 'START_NODE_NOT_MOVING':\r\n            return { ...state, isStartMoving: false};\r\n\r\n        case 'END_NODE_MOVING':\r\n            return { ...state, isEndMoving: true};\r\n\r\n        case 'END_NODE_NOT_MOVING':\r\n            return { ...state, isEndMoving: false};\r\n\r\n        case 'SET_START_NODE':\r\n            return { ...state, \r\n                    start: {\r\n                            row: action.payload.newStart.row,\r\n                            col: action.payload.newStart.col\r\n                        } \r\n                    }\r\n\r\n        case 'SET_END_NODE':\r\n            return { ...state, \r\n                    end: {\r\n                        row: action.payload.newEnd.row,\r\n                        col: action.payload.newEnd.col} \r\n                    }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default combineReducers({\r\n    algorithmStatus: algorithmStatusReducer,\r\n    selectedAlgorithm: selectAlgorithmReducer,\r\n    isShowingPath: isShowingPathReducer,\r\n    board: boardReducer,\r\n    dataStructure: dataStructureReducer,\r\n    isMousePressed: mousePressedReducer,\r\n    moveStartEnd: moveStartEndReducer\r\n});","import '../css/Node.css';\r\nimport React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { \r\n    mouseIsNotPressed, \r\n    dispatchMultipleActions, \r\n    toggleWallNode,  \r\n    mouseIsPressed,\r\n    startNodeMoving,\r\n    endNodeMoving,\r\n    setStartNode,\r\n    setEndNode,\r\n    calculateHCost,\r\n    rerunAlgorithm\r\n} from '../actions'\r\n\r\nclass Node extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.onMouseDownHandler = this.onMouseDownHandler.bind(this);\r\n        this.onMouseEnterHandler = this.onMouseEnterHandler.bind(this);\r\n        this.onMouseUpHandler = this.onMouseUpHandler.bind(this);\r\n        this.onMouseLeaveHandler = this.onMouseLeaveHandler.bind(this);\r\n    }\r\n\r\n    onMouseDownHandler() {\r\n        const { \r\n            isFrontier,\r\n            isVisited,\r\n            isFinish,\r\n            isStart,\r\n            dispatchMultipleActions,\r\n            toggleWallNode,\r\n            mouseIsPressed,\r\n            startNodeMoving,\r\n            endNodeMoving,\r\n            algorithmStatus\r\n        } = this.props;\r\n\r\n        const onMouseDownActions = [];\r\n\r\n        if(!isFrontier && !isVisited && !isFinish && !isStart) {\r\n            onMouseDownActions.push(() => toggleWallNode());\r\n        }\r\n\r\n        if(isStart && (algorithmStatus === 'STOPPED' || algorithmStatus === 'COMPLETE')) {\r\n            onMouseDownActions.push(() => startNodeMoving(true));\r\n        }\r\n\r\n        if(isFinish && (algorithmStatus === 'STOPPED' || algorithmStatus === 'COMPLETE')) {\r\n            onMouseDownActions.push(() => endNodeMoving(true));\r\n        }\r\n\r\n        onMouseDownActions.push(() => mouseIsPressed());\r\n        dispatchMultipleActions(onMouseDownActions);\r\n    }\r\n\r\n    onMouseUpHandler() {\r\n       const {\r\n           mouseIsNotPressed,\r\n           startNodeMoving,\r\n           endNodeMoving,\r\n           dispatchMultipleActions\r\n       } = this.props;\r\n\r\n       const onMouseDownActions = [];\r\n\r\n       onMouseDownActions.push(() => mouseIsNotPressed());\r\n       onMouseDownActions.push(() => startNodeMoving(false));\r\n       onMouseDownActions.push(() => endNodeMoving(false));\r\n       dispatchMultipleActions(onMouseDownActions);\r\n    }\r\n\r\n    onMouseEnterHandler() {\r\n        const { \r\n            row, col, \r\n            isFrontier,\r\n            isVisited,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            dispatchMultipleActions,\r\n            toggleWallNode,\r\n            isMousePressed,\r\n            isStartMoving,\r\n            isEndMoving,\r\n            setStartNode,\r\n            setEndNode,\r\n            algorithmStatus,\r\n            selectedAlgorithm,\r\n            rerunAlgorithm,\r\n            startNode,\r\n            endNode,\r\n        } = this.props;\r\n\r\n        const onMouseDownActions = []\r\n\r\n        if(!isMousePressed) {\r\n            return;\r\n        }\r\n\r\n        if(isStartMoving) {\r\n            if(isFinish) {\r\n                return;\r\n            }\r\n            onMouseDownActions.push(() => setStartNode({ row, col }, startNode));\r\n\r\n            if(algorithmStatus === 'COMPLETE') {\r\n                onMouseDownActions.push(() => rerunAlgorithm(selectedAlgorithm, { row, col }, endNode));\r\n            }\r\n        }\r\n\r\n        if(isEndMoving) {\r\n            if(isStart) {\r\n                return;\r\n            }\r\n            onMouseDownActions.push(() => setEndNode({ row, col }, endNode));\r\n\r\n            if(algorithmStatus === 'COMPLETE') {\r\n                onMouseDownActions.push(() => rerunAlgorithm(selectedAlgorithm, startNode, { row, col }));\r\n            }\r\n        }\r\n\r\n        if(!isStartMoving && !isEndMoving && !isWall && !isFrontier && !isVisited && !isFinish && !isStart) {\r\n            onMouseDownActions.push(() => toggleWallNode());\r\n        }\r\n\r\n        dispatchMultipleActions(onMouseDownActions);\r\n    }\r\n\r\n    onMouseLeaveHandler() {\r\n    }\r\n\r\n    render() {\r\n\r\n        const { \r\n            row, col, \r\n            isStart, isFinish, isWall, isHead, isVisited, isFrontier, isPath, isBacktrack, fCost, \r\n            selectedAlgorithm\r\n         } = this.props;\r\n\r\n\r\n        const nodeType = isFinish\r\n                        ? 'node-finish'\r\n                        : isStart\r\n                        ? 'node-start'\r\n                        : isPath\r\n                        ? 'node-path'\r\n                        : isWall\r\n                        ? 'node-wall'\r\n                        : isHead\r\n                        ? 'node-head'\r\n                        : isBacktrack\r\n                        ? 'node-backtrack'\r\n                        : isVisited\r\n                        ? 'node-visited'\r\n                        : isFrontier\r\n                        ? 'node-frontier'\r\n                        : ''\r\n\r\n        const value = ((selectedAlgorithm === 'ASTAR' || selectedAlgorithm === 'GREED') && (fCost !== null)) ? fCost : ''\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className={`node ${nodeType}`}\r\n                onMouseDown={this.onMouseDownHandler}\r\n                onMouseUp={this.onMouseUpHandler}\r\n                onMouseEnter={this.onMouseEnterHandler}\r\n                onMouseLeave={this.onMouseLeaveHandler}>\r\n                {value}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n    const node = state.board.grid[ownProps.row][ownProps.col];\r\n    const { moveStartEnd } = state;\r\n\r\n    return {\r\n        isStart:  node.isStart,\r\n        isFinish: node.isFinish,\r\n        isWall: node.isWall,\r\n        isFrontier: node.isFrontier,\r\n        isVisited: node.isVisited,\r\n        isPath: node.isPath,\r\n        isHead: node.isHead,\r\n        isBacktrack: node.isBacktrack,\r\n        isMousePressed: state.isMousePressed,\r\n        hCost: node.hCost,\r\n        gCost: node.gCost,\r\n        fCost: node.fCost,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isStartMoving: moveStartEnd.isStartMoving,\r\n        isEndMoving: moveStartEnd.isEndMoving,\r\n        startNode: moveStartEnd.start,\r\n        endNode: moveStartEnd.end\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch, ownProps) => {\r\n    return {\r\n        toggleWallNode: () => dispatch(toggleWallNode(ownProps.row, ownProps.col)),\r\n        mouseIsPressed: () => dispatch(mouseIsPressed()),\r\n        mouseIsNotPressed: () => dispatch(mouseIsNotPressed()),\r\n        dispatchMultipleActions: (actions) => dispatchMultipleActions(actions),\r\n        startNodeMoving: (isMoving) => dispatch(startNodeMoving(isMoving)),\r\n        endNodeMoving: (isMoving) => dispatch(endNodeMoving(isMoving)),\r\n        setStartNode: (newStart, oldStart) => dispatch(setStartNode(newStart, oldStart)),\r\n        setEndNode: (newEnd, oldEnd) => dispatch(setEndNode(newEnd, oldEnd)),\r\n        calculateHCost: (endNode) => dispatch(calculateHCost(endNode)),\r\n        rerunAlgorithm: (selectedAlgorithm, startNode, endNode) => dispatch(rerunAlgorithm(selectedAlgorithm, startNode, endNode))\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Node);","import React from 'react';\r\nimport Node from './Node';\r\nimport { connect } from 'react-redux';\r\nimport '../css/Grid.css';\r\nimport { generateNodeKey } from '../util/GridGenerationUtil';\r\n\r\nclass Grid extends React.Component {\r\n\r\n    render() {\r\n        const { grid } = this.props;\r\n\r\n        return (\r\n            <div className=\"grid\">\r\n                {\r\n                    grid.map((row, rowIndex) => {\r\n                        return (\r\n                            <div className=\"grid-row\" key={rowIndex}>\r\n                                {\r\n                                    row.map((col, colIndex) => {\r\n                                        return (<Node \r\n                                                    key={generateNodeKey(rowIndex, colIndex)}\r\n                                                    row={rowIndex} \r\n                                                    col={colIndex}/>);\r\n                                    })\r\n                                }\r\n                            </div>\r\n                        )\r\n                        \r\n                    })\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.board.grid,\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Grid);","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Button } from 'semantic-ui-react';\r\nimport { carouselCards, algorithmIndexMapping } from '../../constants';\r\nimport { setSelectedAlgorithm } from '../../actions';\r\nimport '../../css/Carousel.css';\r\n\r\nclass Carousel extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.setSlide = this.setSlide.bind(this);\r\n        this.plusSlides = this.plusSlides.bind(this);\r\n        this.updateDots = this.updateDots.bind(this);\r\n        this.onSelect = this.onSelect.bind(this);\r\n\r\n        const initialIndex = props.selectedAlgorithm === 'none' ? 0 : algorithmIndexMapping[props.selectedAlgorithm];\r\n        this.state = { slideIndex: initialIndex, carouselCards: carouselCards};\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.updateDots(this.state.slideIndex);\r\n    }\r\n\r\n    updateDots(index) {\r\n        var dots = document.getElementsByClassName(\"dot\");\r\n        for (let i = 0; i < dots.length; i++) {\r\n            dots[i].className = dots[i].className.replace(\" active\", \"\");\r\n        }\r\n        dots[index].className += \" active\";\r\n    }\r\n\r\n    // Next/previous controls\r\n    plusSlides(n) {\r\n        let newSlideIndex = this.state.slideIndex + n;\r\n\r\n        if (newSlideIndex > this.state.carouselCards.length - 1) {\r\n            newSlideIndex = 0;\r\n        } else if(newSlideIndex < 0) {\r\n            newSlideIndex = this.state.carouselCards.length - 1;\r\n        }\r\n        \r\n        this.updateDots(newSlideIndex);\r\n        this.setState({slideIndex: newSlideIndex});\r\n    }\r\n\r\n    setSlide(index) {\r\n        this.setState({ slideIndex: index });\r\n        this.updateDots(index);\r\n    }\r\n\r\n    onSelect() {\r\n        const { close, setSelectedAlgorithm } = this.props;\r\n        const { slideIndex, carouselCards } = this.state;\r\n        setSelectedAlgorithm(carouselCards[slideIndex].value);\r\n        close();\r\n    }\r\n\r\n    render() {\r\n        const { slideIndex } = this.state;\r\n        const currentCard = carouselCards[slideIndex];\r\n        const { header, description, src } = currentCard;\r\n\r\n        return (\r\n            <>\r\n                <div className=\"slideshow-container\">\r\n\r\n                    <div className=\"mySlides fade\">\r\n                        <h1 className=\"ui header\">{header}</h1>\r\n                        <img src={src} alt={`${header} gif`} height=\"300\" width=\"300\"/>\r\n                        <div className=\"description\">{description}</div>\r\n                    </div>\r\n\r\n                    <a className=\"prev\" onClick={() => this.plusSlides(-1)}>&#10094;</a>\r\n                    <a className=\"next\" onClick={() => this.plusSlides(1)}>&#10095;</a>\r\n\r\n                </div>\r\n                <br/>\r\n\r\n                <div style={{textAlign: \"center\"}}>\r\n                    <span className=\"dot\" onClick={() => this.setSlide(0)}></span> \r\n                    <span className=\"dot\" onClick={() => this.setSlide(1)}></span> \r\n                    <span className=\"dot\" onClick={() => this.setSlide(2)}></span> \r\n                    <span className=\"dot\" onClick={() => this.setSlide(3)}></span> \r\n                </div>\r\n                <br/>\r\n                <Button\r\n                    positive\r\n                    onClick={this.onSelect}\r\n                    content='Select'/>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        selectedAlgorithm: state.selectedAlgorithm\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        setSelectedAlgorithm: (algorithm) => {dispatch(setSelectedAlgorithm(algorithm))}\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Carousel);","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Modal } from 'semantic-ui-react';\r\nimport Carousel from '../SelectAlgorithmModal/Carousel';\r\nimport { carouselCards } from '../../constants';\r\n\r\nclass SelectAlgorithmModal extends React.Component {\r\n    state = { open: false }\r\n\r\n    closeConfigShow = (closeOnEscape, closeOnDimmerClick) => () => {\r\n        this.setState({ closeOnEscape, closeOnDimmerClick, open: true })\r\n    }\r\n\r\n    close = () => this.setState({ open: false })\r\n\r\n    render() {\r\n        let buttonText = 'Select Algorithm';\r\n\r\n        for(let i = 0; i < carouselCards.length; i++) {\r\n            if(carouselCards[i].value === this.props.selectedAlgorithm) {\r\n                buttonText = carouselCards[i].header;\r\n                break;\r\n            }\r\n        }\r\n\r\n        const isDisabled = this.props.algorithmStatus !== 'STOPPED';\r\n        let triggerClass = isDisabled ? \"disabled\" : \"\";\r\n\r\n        return (\r\n            <Modal \r\n                open={this.state.open}\r\n                trigger={<div className={`item side ${triggerClass}`} onClick={isDisabled ? () => {} : this.closeConfigShow(false, true)}> {buttonText} </div>}\r\n                closeOnEscape={this.state.closeOnEscape}\r\n                closeOnDimmerClick={this.state.closeOnDimmerClick}\r\n                onClose={this.close}\r\n                style={{textAlign: 'center', marginBottom: 'auto'}}\r\n                size={\"tiny\"}\r\n            >\r\n                <Modal.Header style={{backgroundColor: \"rgb(12, 53, 71)\", color: \"white\"}}>Select Algorithm</Modal.Header>\r\n                    <Modal.Content>\r\n                        <Carousel close={this.close}/>\r\n                    </Modal.Content>\r\n            </Modal>\r\n            \r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(SelectAlgorithmModal);","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport BFS from '../util/algorithms/BFS';\r\nimport DFS from '../util/algorithms/DFS';\r\nimport AStar from '../util/algorithms/AStar';\r\nimport Greedy from '../util/algorithms/Greedy';\r\nimport { isAlgorithmRunning, isAlgorithmStopped } from '../util/AlgorithmUtil'\r\nimport SelectAlgorithmModal from './SelectAlgorithmModal/SelectAlgorithmModal';\r\nimport '../css/Menu.css';\r\nimport { \r\n    showInitialBoard, \r\n    runAlgorithm, \r\n    stopAlgorithm, \r\n    pauseAlgorithm, \r\n    completeAlgorithm, \r\n    toggleFrontierNode, \r\n    toggleVisitedNode, \r\n    togglePathNode, \r\n    resetDataStructure, \r\n    setDataStructure, \r\n    notShowingPath, \r\n    markHeadNode, \r\n    unmarkHeadNode, \r\n    resetBoardWithWalls, \r\n    markBacktrackNodes,\r\n    generateRandomGrid,\r\n    dispatchMultipleActions,\r\n    calculateHCost\r\n} from '../actions';\r\n\r\nclass Menu extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.runSelectedAlgorithm = this.runSelectedAlgorithm.bind(this);\r\n        this.clearBoard = this.clearBoard.bind(this);\r\n    }\r\n\r\n    async runSelectedAlgorithm() {\r\n        const { \r\n            selectedAlgorithm, \r\n            runAlgorithm, \r\n            pauseAlgorithm,\r\n            completeAlgorithm, \r\n            grid,\r\n            dataStructure,\r\n            toggleVisitedNode, \r\n            toggleFrontierNode, \r\n            togglePathNode,\r\n            setDataStructure,\r\n            isShowingPath,\r\n            markHeadNode,\r\n            unmarkHeadNode,\r\n            algorithmStatus,\r\n            markBacktrackNodes,\r\n            startNode,\r\n            endNode,\r\n            calculateHCost\r\n        } = this.props;\r\n\r\n        if(selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') {\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmRunning()) {\r\n            pauseAlgorithm();\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            calculateHCost(endNode);\r\n        }\r\n\r\n        runAlgorithm();\r\n        window.scrollTo(0,50);\r\n\r\n        switch(selectedAlgorithm) {\r\n            case \"BFS\":\r\n                const bfs = new BFS(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure);\r\n                await bfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"DFS\":\r\n                const dfs = new DFS(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, markBacktrackNodes, setDataStructure);\r\n                await dfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"ASTAR\":\r\n                const aStar = new AStar(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure);\r\n                await aStar.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"GREED\":\r\n                const greedy = new Greedy(startNode, toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure);\r\n                await greedy.run(grid, dataStructure);\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        \r\n        if(isAlgorithmRunning()) {\r\n            completeAlgorithm();\r\n        }\r\n\r\n    }\r\n\r\n    clearBoard(clearWall) {\r\n        const { \r\n            notShowingPath,\r\n            stopAlgorithm,\r\n            resetDataStructure,\r\n            showInitialBoard,\r\n            resetBoardWithWalls,\r\n            dispatchMultipleActions\r\n        } = this.props;\r\n\r\n        const clearBoardActions = [notShowingPath,\r\n                                   stopAlgorithm,\r\n                                   resetDataStructure];\r\n\r\n        if(clearWall) {\r\n            clearBoardActions.push(showInitialBoard);\r\n        } else {\r\n            clearBoardActions.push(resetBoardWithWalls);\r\n        }\r\n\r\n        dispatchMultipleActions(clearBoardActions);\r\n    }\r\n\r\n    render() {\r\n        const { selectedAlgorithm, algorithmStatus, isShowingPath, generateRandomGrid } = this.props;\r\n\r\n        const runButtonClass = (selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') ? \"disabledRun\" : \"run\";\r\n\r\n        const canGenerateRandomGrid = algorithmStatus === 'STOPPED';\r\n\r\n        const randomGridButtonClass = canGenerateRandomGrid ? \"\" : \"disabled\"; \r\n\r\n        let runButtonText = \"Run\";\r\n        let runButtonColor = \"\";\r\n\r\n        if((algorithmStatus === 'RUNNING' && isShowingPath) || algorithmStatus === 'COMPLETE') {\r\n            runButtonText = \"Complete\";\r\n            runButtonColor = \"complete\";\r\n        }\r\n\r\n        if(algorithmStatus === 'RUNNING' && !isShowingPath) {\r\n            runButtonText = \"Pause\";\r\n            runButtonColor = \"pause\";\r\n        }\r\n\r\n        return (\r\n            <div className=\"bar\">\r\n                <div onClick={canGenerateRandomGrid ? generateRandomGrid : () => {}} className ={`item side ${randomGridButtonClass}`}>\r\n                    Generate Random Grid\r\n                </div>\r\n                <SelectAlgorithmModal />\r\n                <div onClick={this.runSelectedAlgorithm} className={`item ${runButtonClass} ${runButtonColor}`}>\r\n                    {runButtonText}!\r\n                </div>\r\n                <div onClick={() => this.clearBoard(false)} className=\"item side\">\r\n                    Clear Path\r\n                </div >\r\n                <div onClick={() => this.clearBoard(true)} className=\"item side\">\r\n                    Clear Board\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.board.grid,\r\n        dataStructure: state.dataStructure,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isShowingPath: state.isShowingPath,\r\n        statistics: state.board.statistics,\r\n        startNode: state.moveStartEnd.start,\r\n        endNode: state.moveStartEnd.end\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        showInitialBoard: (endNode) => dispatch(showInitialBoard(endNode)),\r\n        runAlgorithm: () => dispatch(runAlgorithm()),\r\n        stopAlgorithm: () => dispatch(stopAlgorithm()),\r\n        pauseAlgorithm: () => dispatch(pauseAlgorithm()),\r\n        completeAlgorithm: () => dispatch(completeAlgorithm()),\r\n        toggleVisitedNode: (row, col) => dispatch(toggleVisitedNode(row, col)),\r\n        toggleFrontierNode: (row, col) => dispatch(toggleFrontierNode(row, col)),\r\n        togglePathNode: (row, col) => dispatch(togglePathNode(row, col)),\r\n        resetDataStructure: () => dispatch(resetDataStructure()),\r\n        setDataStructure: (dataStructure) => dispatch(setDataStructure(dataStructure)),\r\n        notShowingPath: () => dispatch(notShowingPath()),\r\n        markHeadNode: (row, col) => dispatch(markHeadNode(row, col)),\r\n        unmarkHeadNode: (row, col) => dispatch(unmarkHeadNode(row, col)),\r\n        resetBoardWithWalls: (endNode) => dispatch(resetBoardWithWalls(endNode)),\r\n        markBacktrackNodes: (array) => dispatch(markBacktrackNodes(array)),\r\n        generateRandomGrid: () => dispatch(generateRandomGrid()),\r\n        dispatchMultipleActions: (actions) => dispatchMultipleActions(actions),\r\n        calculateHCost: (endNode) => dispatch(calculateHCost(endNode))\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Menu);","import React from 'react';\r\nimport { connect } from 'react-redux';\r\n\r\nclass InfoPanel extends React.Component {\r\n    render() {\r\n\r\n        const { unvisited,\r\n                visited,\r\n                wall,\r\n                backtrack,\r\n                frontier,\r\n                path } = this.props.statistics;\r\n\r\n        const displayValue = (value) => (value === 0) ? \"\" : `${value} ` \r\n\r\n\r\n        return (\r\n            <div style={{width: \"85%\", margin: \"auto\", marginTop: \"2vh\"}}>\r\n                <div className=\"ui small eight statistics\">\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">\r\n                            <div className={`node node-start`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} />\r\n                        </div>\r\n                        <div class=\"label\">start</div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">\r\n                            <div className={`node node-finish`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} />\r\n                        </div>\r\n                        <div class=\"label\">end</div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(unvisited)} <div className={`node node-unvisited`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>unvisited</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(wall)} <div className={`node node-wall`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>wall</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(visited)} <div className={`node node-visited`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>visited</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(backtrack)} <div className={`node node-backtrack`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>backtrack</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(frontier)} <div className={`node node-frontier`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>frontier</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                    <div class=\"statistic\">\r\n                        <div class=\"value\">{displayValue(path)} <div className={`node node-path`} style={{border: \"2px solid white\", borderRadius: \"5px\"}} /></div>\r\n                        <div class=\"label\">\r\n                            <div>path</div>\r\n                        </div>\r\n                    </div>\r\n    \r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n   \r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.board.grid,\r\n        dataStructure: state.dataStructure,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isShowingPath: state.isShowingPath,\r\n        statistics: state.board.statistics\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(InfoPanel);","import React from 'react';\r\nimport Grid from './Grid';\r\nimport Menu from './Menu';\r\nimport InfoPanel from './InfoPanel';\r\nimport '../css/App.css';\r\n\r\nclass App extends React.Component {\r\n\r\n    render() {\r\n        return (\r\n            <div id=\"wrapper\" className=\"App\">\r\n                <Menu/>\r\n                <Grid />\r\n                <InfoPanel/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport { createStore } from 'redux';\r\nimport reducer from './reducers';\r\nimport App from './components/App';\r\nimport './css/App.css';\r\n\r\nexport const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\r\n\r\nReactDOM.render(<Provider store={store}><App /></Provider>, document.querySelector('#root'));\r\n"],"sourceRoot":""}