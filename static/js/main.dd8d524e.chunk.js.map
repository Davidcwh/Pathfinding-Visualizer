{"version":3,"sources":["constants.js","util/GridGenerationUtil.js","reducers/index.js","components/Node.js","actions/index.js","components/Grid.js","util/AlgorithmUtil.js","util/algorithms/BFS.js","util/algorithms/DFS.js","components/SelectAlgorithmDropdown.js","components/Menu.js","components/InfoPanel.js","components/App.js","index.js"],"names":["gridDetails","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","TOTAL_ROW","TOTAL_COL","generateInitalGrid","row","col","grid","r","currentRow","c","push","isStart","isFinish","distance","Infinity","isVisited","isWall","isFrontier","isHead","previousNode","isPath","generateToggleWallGrid","currentGrid","newGrid","slice","node","newNode","generateToggleFrontierGrid","generateMarkVisitedGrid","generateMarkPathGrid","generateGridWithWalls","currentNode","generateMarkHeadGrid","generateUnmarkHeadGrid","generateNodeKey","toString","combineReducers","algorithmStatus","state","action","type","selectedAlgorithm","isShowingPath","payload","dataStructure","isMousePressed","connect","ownProps","dispatch","onMouseDown","toggleWallNode","mouseIsNotPressed","nodeType","id","className","onMouseUp","onMouseEnter","Grid","this","props","map","rowIndex","key","colIndex","React","Component","sleep","ms","Promise","resolve","setTimeout","getNodeNeighbours","neighbours","upNode","rightNode","downNode","leftNode","isAlgorithmRunning","console","log","store","getState","isAlgorithmPaused","isAlgorithmStopped","showPath","togglePathNode","a","finishNode","stack","Stack","undefined","isEmpty","pop","BFS","toggleVisitedNode","toggleFrontierNode","setDataStructure","queue","Queue","startNode","enqueue","dequeue","i","length","neighbour","DFS","markHeadNode","unmarkHeadNode","stacks","unvisitedStack","visitedStack","removeFromStack","filter","backtrack","visitedNode","contains","peek","target","newStack","tempStack","current","options","text","value","SelectAlgorithmDropdown","selectedAlgorithmText","disabled","Dropdown","fluid","simple","item","onChange","event","data","algorithm","Menu","runSelectedAlgorithm","bind","clearBoard","runAlgorithm","stopAlgorithm","pauseAlgorithm","completeAlgorithm","bfs","run","dfs","clearWall","notShowingPath","resetDataStructure","showInitialBoard","resetBoardWithWalls","runButtonClass","runButtonText","onClick","LegendItem","style","margin","border","borderRadius","InfoPanel","App","createStore","reducer","window","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","render","document","querySelector"],"mappings":"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","file":"static/js/main.dd8d524e.chunk.js","sourcesContent":["export const gridDetails = {\r\n    TOTAL_ROW: 21,\r\n    TOTAL_COL: 50,\r\n    START_NODE_ROW: 10,\r\n    START_NODE_COL: 5,\r\n    FINISH_NODE_ROW: 10,\r\n    FINISH_NODE_COL: 45 \r\n}","import { gridDetails } from '../constants';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL, TOTAL_ROW, TOTAL_COL} = gridDetails;\r\n\r\nfunction NodeFactory(row, col) {\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        isFrontier: false,\r\n        isHead: false,\r\n        previousNode: null,\r\n        isPath: false\r\n      };\r\n}\r\n\r\nexport function generateInitalGrid() {\r\n    const grid = [];\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        const currentRow = [];\r\n\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            currentRow.push(NodeFactory(r, c));\r\n        }\r\n\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    return grid;\r\n}\r\n\r\nexport function generateToggleWallGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateToggleFrontierGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isFrontier: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkVisitedGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isVisited: true,\r\n        isFrontier: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkPathGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isPath: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateGridWithWalls(currentGrid) {\r\n    const newGrid = generateInitalGrid();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const currentNode = currentGrid[r][c];\r\n            if(!currentNode.isFinish && !currentNode.isStart) {  \r\n                newGrid[r][c].isWall = currentNode.isWall;\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateUnmarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateNodeKey(row, col) {\r\n    return (row * TOTAL_ROW + col).toString();\r\n}","import { combineReducers } from 'redux';\r\nimport { generateInitalGrid, generateToggleWallGrid, generateToggleFrontierGrid, generateMarkVisitedGrid, generateMarkPathGrid, generateGridWithWalls, generateMarkHeadGrid, generateUnmarkHeadGrid } from '../util/GridGenerationUtil'\r\n\r\nconst gridReducer = (state=generateInitalGrid(), action) => {\r\n    switch(action.type) {\r\n        case 'TOOGLE_WALL_NODE':\r\n            return generateToggleWallGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'TOGGLE_FRONTIER_NDOE':\r\n            return generateToggleFrontierGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'TOGGLE_VISITED_NODE':\r\n            return generateMarkVisitedGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'TOGGLE_PATH_NODE':\r\n            return generateMarkPathGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'SHOW_INITIAL_BOARD':\r\n            return generateInitalGrid();\r\n\r\n        case 'RESET_BOARD_WITH_WALLS':\r\n            return generateGridWithWalls(state);\r\n\r\n        case 'MARK_HEAD_NODE':\r\n            return generateMarkHeadGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'UNMARK_HEAD_NODE':\r\n            return generateUnmarkHeadGrid(action.payload.row, action.payload.col, state);\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst dataStructureReducer = (state=null, action) => {\r\n    switch(action.type) {\r\n        case 'RESET_DATA_STRUCTURE':\r\n            return null;\r\n\r\n        case 'SET_DATA_STRUCTURE':\r\n            return action.payload;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst mousePressedReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'PRESSED':\r\n            return true;\r\n\r\n        case 'NOT_PRESSED':\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst selectAlgorithmReducer = (state='none', action) => {\r\n    switch(action.type) {\r\n        case 'BFS':\r\n            return 'BFS';\r\n\r\n        case 'DFS':\r\n            return 'DFS';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst algorithmStatusReducer = (state='STOPPED', action) => {\r\n    switch(action.type) {\r\n        case 'RUN_ALGORITHM':\r\n            return 'RUNNING';\r\n\r\n        case 'STOP_ALGORITHM':\r\n            return 'STOPPED';\r\n\r\n        case 'PAUSE_ALGORITHM':\r\n            return 'PAUSED';\r\n\r\n        case 'COMPLETE_ALGORITHM':\r\n            return 'COMPLETE';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst isShowingPathReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'SHOWING_PATH':\r\n            return true;\r\n\r\n        case 'NOT_SHOWING_PATH':\r\n            return false;\r\n        \r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default combineReducers({\r\n    algorithmStatus: algorithmStatusReducer,\r\n    selectedAlgorithm: selectAlgorithmReducer,\r\n    isShowingPath: isShowingPathReducer,\r\n    grid: gridReducer,\r\n    dataStructure: dataStructureReducer,\r\n    isMousePressed: mousePressedReducer\r\n});","import '../css/Node.css';\r\nimport React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { mouseIsNotPressed, onMouseDown } from '../actions'\r\n\r\nconst Node = ({ row, col, isStart, isFinish, isWall, isHead, isVisited, isFrontier, isPath, isMousePressed, onMouseDown, mouseIsNotPressed}) => {\r\n    const nodeType = isFinish\r\n        ? 'node-finish'\r\n        : isStart\r\n        ? 'node-start'\r\n        : isPath\r\n        ? 'node-path'\r\n        : isWall\r\n        ? 'node-wall'\r\n        : isHead\r\n        ? 'node-head'\r\n        : isVisited\r\n        ? 'node-visited'\r\n        : isFrontier\r\n        ? 'node-frontier'\r\n        : ''\r\n\r\n    return <div \r\n            id={`node-${row}-${col}`}\r\n            className={`node ${nodeType}`}\r\n            onMouseDown={(!isFrontier && !isVisited && !isFinish && !isStart) ? onMouseDown : () => {}}\r\n            onMouseUp={mouseIsNotPressed}\r\n            onMouseEnter={(isMousePressed && !isWall && !isFrontier && !isVisited && !isFinish && !isStart) ? onMouseDown : () => {}}></div>\r\n}\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n    const node = state.grid[ownProps.row][ownProps.col];\r\n\r\n    return {\r\n        isStart:  node.isStart,\r\n        isFinish: node.isFinish,\r\n        isWall: node.isWall,\r\n        isFrontier: node.isFrontier,\r\n        isVisited: node.isVisited,\r\n        isPath: node.isPath,\r\n        isHead: node.isHead,\r\n        isMousePressed: state.isMousePressed\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch, ownProps) => {\r\n    return {\r\n        onMouseDown: () => onMouseDown(ownProps.row, ownProps.col, dispatch),\r\n        mouseIsNotPressed: () => dispatch(mouseIsNotPressed()),\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Node);","const toggleWallNode = (row, col) => {\r\n    return {\r\n        type: 'TOOGLE_WALL_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nconst mouseIsPressed = () => {\r\n    return { type: 'PRESSED'};\r\n}\r\n\r\nexport const mouseIsNotPressed = () => {\r\n    return { type: 'NOT_PRESSED'};\r\n}\r\n\r\nexport const onMouseDown = (row, col, dispatch) => {\r\n    dispatch(toggleWallNode(row, col));\r\n    dispatch(mouseIsPressed());\r\n}\r\n\r\n\r\nexport const runAlgorithm = () => {\r\n    return { type: 'RUN_ALGORITHM'};\r\n}\r\n\r\nexport const stopAlgorithm = () => {\r\n    return { type: 'STOP_ALGORITHM'};\r\n}\r\n\r\nexport const showInitialBoard = () => {\r\n    return { type: 'SHOW_INITIAL_BOARD'};\r\n}\r\n\r\nexport const resetBoardWithWalls = () => {\r\n    return { type: 'RESET_BOARD_WITH_WALLS'};\r\n}\r\n\r\nexport const pauseAlgorithm = () => {\r\n    return { type: 'PAUSE_ALGORITHM'};\r\n}\r\n\r\nexport const completeAlgorithm = () => {\r\n    return { type: 'COMPLETE_ALGORITHM'};\r\n}\r\n\r\nexport const toggleFrontierNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_FRONTIER_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const toggleVisitedNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_VISITED_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const togglePathNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_PATH_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const setSelectedAlgorithm = (algorithmName) => {\r\n    return {\r\n        type: algorithmName\r\n    }\r\n}\r\n\r\nexport const resetDataStructure = () => {\r\n    return { type: 'RESET_DATA_STRUCTURE' }\r\n}\r\n\r\nexport const setDataStructure = (dataStructure) => {\r\n    return {\r\n        type: 'SET_DATA_STRUCTURE',\r\n        payload: dataStructure\r\n    }\r\n}\r\n\r\nexport const showingPath = () => {\r\n    return { type: 'SHOWING_PATH' };\r\n}\r\n\r\nexport const notShowingPath = () => {\r\n    return { type: 'NOT_SHOWING_PATH' };\r\n}\r\n\r\nexport const markHeadNode = (row, col) => {\r\n    return {\r\n        type: 'MARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const unmarkHeadNode = (row, col) => {\r\n    return {\r\n        type: 'UNMARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n","import React from 'react';\r\nimport Node from './Node';\r\nimport { connect } from 'react-redux';\r\nimport '../css/Grid.css';\r\nimport { generateNodeKey } from '../util/GridGenerationUtil'\r\n\r\nclass Grid extends React.Component {\r\n\r\n    render() {\r\n        const {grid} = this.props;\r\n\r\n        return (\r\n            <div className=\"grid\">\r\n                {\r\n                    grid.map((row, rowIndex) => {\r\n                        return (\r\n                            <div className=\"grid-row\" key={rowIndex}>\r\n                                {\r\n                                    row.map((col, colIndex) => {\r\n                                        return (<Node \r\n                                                    key={generateNodeKey(rowIndex, colIndex)}\r\n                                                    row={rowIndex} \r\n                                                    col={colIndex}/>);\r\n                                    })\r\n                                }\r\n                            </div>\r\n                        )\r\n                        \r\n                    })\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.grid,\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Grid);","import { gridDetails } from '../constants';\r\nimport { store } from '../index';\r\nimport Stack from '@datastructures-js/stack';\r\nimport { showingPath, notShowingPath } from '../actions';\r\n\r\nconst { TOTAL_ROW, TOTAL_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n\r\nexport function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nexport const getNodeNeighbours = (state, node) => {\r\n    let neighbours = [];\r\n\r\n    if(node.row > 0) {\r\n        const upNode = state[node.row - 1][node.col];\r\n        neighbours.push(upNode);\r\n    }\r\n\r\n    if(node.col < (TOTAL_COL - 1)) {\r\n        const rightNode = state[node.row][node.col + 1];\r\n        neighbours.push(rightNode);\r\n    }\r\n\r\n    if(node.row < (TOTAL_ROW - 1)) {\r\n        const downNode = state[node.row + 1][node.col];\r\n        neighbours.push(downNode);\r\n    }\r\n\r\n    if(node.col > 0) {\r\n        const leftNode = state[node.row][node.col - 1];\r\n        neighbours.push(leftNode);\r\n    }\r\n\r\n    return neighbours;\r\n}\r\n\r\nexport const isAlgorithmRunning = () => {\r\n    console.log(`isAlgorithmRunning:${store.getState().algorithmStatus} `)\r\n    return (store.getState().algorithmStatus === 'RUNNING');\r\n}\r\n\r\nexport const isAlgorithmPaused = () => {\r\n    return (store.getState().algorithmStatus === 'PAUSED');\r\n}\r\n\r\nexport const isAlgorithmStopped = () => {\r\n    return (store.getState().algorithmStatus === 'STOPPED');\r\n}\r\n\r\nconst isShowingPath = () => {\r\n    return store.getState().isShowingPath;\r\n}\r\n\r\nexport async function showPath(state, togglePathNode) {\r\n    store.dispatch(showingPath());\r\n\r\n    const finishNode = state[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let currentNode = finishNode;\r\n    const stack = new Stack();\r\n    while(currentNode !== undefined) {\r\n        stack.push(currentNode);\r\n\r\n        if(!currentNode.previousNode) {\r\n            break;\r\n        }\r\n        currentNode = state[currentNode.previousNode.row][currentNode.previousNode.col];\r\n    }\r\n\r\n    while(!stack.isEmpty()) {\r\n        if(isAlgorithmStopped() || !isShowingPath()) {\r\n            return;\r\n        }\r\n\r\n        let node = stack.pop();\r\n        togglePathNode(node.row, node.col);\r\n        await sleep(20);\r\n    }\r\n\r\n    store.dispatch(notShowingPath());\r\n}","import { gridDetails } from '../../constants';\r\nimport { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\n\r\nimport Queue from 'queue-fifo';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n  \r\nexport default class BFS {\r\n    constructor(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure) {\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, queue) {\r\n        if(queue === null) {\r\n            queue = new Queue();\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            queue.enqueue(startNode);\r\n        }\r\n\r\n        while(!queue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = queue.dequeue();\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                await showPath(grid, this.togglePathNode);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                if(!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) {\r\n\r\n                    if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                        await showPath(grid, this.togglePathNode);\r\n                        return;\r\n                    }\r\n\r\n                    neighbour.isFrontier = true;\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n                    queue.enqueue(neighbour);\r\n                }\r\n            }\r\n            await sleep(0);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(queue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n        \r\n    }\r\n}\r\n","import { gridDetails } from '../../constants';\r\nimport { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\nimport Stack from '@datastructures-js/stack';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n\r\nexport default class DFS {\r\n    constructor(toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, setDataStructure) {\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.markHeadNode = markHeadNode;\r\n        this.unmarkHeadNode = unmarkHeadNode;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, stacks) {\r\n        let unvisitedStack = null;\r\n        let visitedStack = null;\r\n\r\n        if(stacks === null) {\r\n            unvisitedStack = new Stack();\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            unvisitedStack.push(startNode);\r\n\r\n            visitedStack = new Stack();\r\n        } else {\r\n            unvisitedStack = stacks.unvisitedStack;\r\n            visitedStack = stacks.visitedStack;\r\n        }\r\n\r\n\r\n        while(!unvisitedStack.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = unvisitedStack.pop();\r\n            unvisitedStack = this.removeFromStack(unvisitedStack, currentNode);\r\n\r\n            currentNode.isVisited = true;\r\n            currentNode.isHead = true;\r\n            this.markHeadNode(currentNode.row, currentNode.col);\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.previousNode !== null) {\r\n                const { row, col } = currentNode.previousNode;\r\n                grid[row][col].isHead = false;\r\n                this.unmarkHeadNode(row, col);\r\n            }\r\n\r\n            if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                await showPath(grid, this.togglePathNode);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = neighbours.length - 1; i >= 0; i--) {\r\n                const neighbour = neighbours[i];\r\n                if(!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) {\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    unvisitedStack.push(neighbour);\r\n                }\r\n            }\r\n\r\n            const validNeighbours = neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier)\r\n\r\n            if(validNeighbours.length === 0) {\r\n                // console.log(`deadend: ${currentNode.row}, ${currentNode.col}`)\r\n                // console.log(`unvisited: ${unvisitedStack.toArray().map(i => `(${i.row}, ${i.col}) `)}`)\r\n                // console.log(`visited: ${visitedStack.toArray().map(i => `(${i.row}, ${i.col}) `)}`)\r\n                currentNode.isHead = false;\r\n                this.unmarkHeadNode(currentNode.row, currentNode.col);\r\n                await sleep(20);\r\n                await this.backtrack(visitedStack, unvisitedStack, grid);\r\n               \r\n            } else {\r\n                visitedStack.push(currentNode);\r\n            }\r\n\r\n            await sleep(20);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure({ unvisitedStack: unvisitedStack, visitedStack: visitedStack });\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n\r\n\r\n    async backtrack(visitedStack, unvisitedStack, grid) {\r\n        while(!visitedStack.isEmpty() && !unvisitedStack.isEmpty()) {\r\n            const visitedNode = visitedStack.pop();\r\n            this.markHeadNode(visitedNode.row, visitedNode.col);\r\n            await sleep(50);\r\n            this.unmarkHeadNode(visitedNode.row, visitedNode.col);\r\n\r\n            let neighbours = getNodeNeighbours(grid, visitedNode);\r\n            neighbours = neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier)\r\n            if(this.contains(neighbours, unvisitedStack.peek())) {\r\n                // console.log(`backtrack ${unvisitedStack.peek().row}, ${unvisitedStack.peek().col}`)\r\n                visitedStack.push(visitedNode);\r\n                return;\r\n            }\r\n            await sleep(50);\r\n        }\r\n    }\r\n\r\n    contains(neighbours, target) {\r\n        for(let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            if(neighbour.row === target.row && neighbour.col === target.col) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n\r\n        return false;\r\n    }\r\n\r\n    removeFromStack(stack, target) {\r\n        const newStack = new Stack();\r\n        const tempStack = new Stack();\r\n\r\n        while(!stack.isEmpty()) {\r\n            const current = stack.pop();\r\n            if(current.row === target.row && current.col === target.col) {\r\n                continue;\r\n            }\r\n\r\n            tempStack.push(current);\r\n        }\r\n\r\n        while(!tempStack.isEmpty()) {\r\n            newStack.push(tempStack.pop());\r\n        }\r\n\r\n        return newStack;\r\n    }\r\n}\r\n","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Dropdown } from 'semantic-ui-react';\r\nimport { setSelectedAlgorithm } from '../actions';\r\n\r\nconst options = [\r\n    { key: 1, text: 'Breadth First Search (BFS)', value: 'BFS' },\r\n    { key: 2, text: 'Depth First Search (DFS)', value: 'DFS' }\r\n  ]\r\n\r\nclass SelectAlgorithmDropdown extends React.Component {\r\n    render() {\r\n        const selectedAlgorithmText = this.props.selectedAlgorithm === 'none' ? 'Select Algorithm' \r\n                                                                              : this.props.selectedAlgorithm === 'BFS'\r\n                                                                              ? 'Breadth First Search (BFS)'\r\n                                                                              : this.props.selectedAlgorithm === 'DFS'\r\n                                                                              ? 'Depth First Search (BFS)'\r\n                                                                              : 'Select Algorithm';\r\n\r\n        const disabled = this.props.algorithmStatus !== 'STOPPED';\r\n\r\n        return (\r\n            <Dropdown \r\n                fluid text={selectedAlgorithmText} \r\n                options={options} \r\n                simple item onChange={(event, data) => {this.props.onChange(data.value)}}\r\n                disabled={disabled}/>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        onChange: (algorithm) => {dispatch(setSelectedAlgorithm(algorithm))}\r\n    }\r\n}\r\n  \r\nexport default connect(mapStateToProps, mapDispatchToProps)(SelectAlgorithmDropdown)","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { showInitialBoard, runAlgorithm, stopAlgorithm, pauseAlgorithm, completeAlgorithm, toggleFrontierNode, toggleVisitedNode, togglePathNode, resetDataStructure, setDataStructure, notShowingPath, markHeadNode, unmarkHeadNode, resetBoardWithWalls } from '../actions';\r\nimport BFS from '../util/algorithms/BFS';\r\nimport DFS from '../util/algorithms/DFS';\r\nimport { isAlgorithmRunning } from '../util/AlgorithmUtil'\r\nimport SelectAlgorithmDropdown from './SelectAlgorithmDropdown';\r\n\r\nclass Menu extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.runSelectedAlgorithm = this.runSelectedAlgorithm.bind(this);\r\n        this.clearBoard = this.clearBoard.bind(this);\r\n\r\n    }\r\n\r\n    async runSelectedAlgorithm() {\r\n        const { selectedAlgorithm, \r\n                runAlgorithm, \r\n                stopAlgorithm, \r\n                pauseAlgorithm,\r\n                completeAlgorithm, \r\n                grid,\r\n                dataStructure,\r\n                toggleVisitedNode, \r\n                toggleFrontierNode, \r\n                togglePathNode,\r\n                setDataStructure,\r\n                isShowingPath,\r\n                markHeadNode,\r\n                unmarkHeadNode,\r\n                algorithmStatus } = this.props;\r\n\r\n        if(selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') {\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmRunning()) {\r\n            pauseAlgorithm();\r\n            return;\r\n        }\r\n\r\n        runAlgorithm();\r\n\r\n        switch(selectedAlgorithm) {\r\n            case \"BFS\":\r\n                const bfs = new BFS(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure);\r\n                await bfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"DFS\":\r\n                const dfs = new DFS(toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, setDataStructure);\r\n                await dfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        \r\n        if(isAlgorithmRunning()) {\r\n            completeAlgorithm();\r\n        }\r\n\r\n    }\r\n\r\n    clearBoard(clearWall) {\r\n        this.props.notShowingPath();\r\n        this.props.stopAlgorithm();\r\n        this.props.resetDataStructure();\r\n\r\n        if(clearWall) {\r\n            this.props.showInitialBoard();\r\n        } else {\r\n            this.props.resetBoardWithWalls();\r\n        }\r\n        \r\n    }\r\n\r\n    render() {\r\n        const { selectedAlgorithm, algorithmStatus, isShowingPath } = this.props;\r\n\r\n        const runButtonClass = (selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') ? \"active item\" : \"item\";\r\n\r\n        let runButtonText = \"Run\";\r\n        if((algorithmStatus === 'RUNNING' && isShowingPath) || algorithmStatus === 'COMPLETE') {\r\n            runButtonText = \"Complete\";\r\n        }\r\n\r\n        if(algorithmStatus === 'RUNNING' && !isShowingPath) {\r\n            runButtonText = \"Pause\";\r\n        }\r\n\r\n        return (\r\n            <div className=\"ui four item menu\">\r\n                <a  onClick={this.runSelectedAlgorithm} className={runButtonClass}>{runButtonText}!</a>\r\n                <SelectAlgorithmDropdown />\r\n                <a onClick={() => this.clearBoard(false)} className=\"item\">Clear Path</a>\r\n                <a onClick={() => this.clearBoard(true)} className=\"item\">Clear Board</a>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.grid,\r\n        dataStructure: state.dataStructure,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isShowingPath: state.isShowingPath\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        showInitialBoard: () => dispatch(showInitialBoard()),\r\n        runAlgorithm: () => dispatch(runAlgorithm()),\r\n        stopAlgorithm: () => dispatch(stopAlgorithm()),\r\n        pauseAlgorithm: () => dispatch(pauseAlgorithm()),\r\n        completeAlgorithm: () => dispatch(completeAlgorithm()),\r\n        toggleVisitedNode: (row, col) => dispatch(toggleVisitedNode(row, col)),\r\n        toggleFrontierNode: (row, col) => dispatch(toggleFrontierNode(row, col)),\r\n        togglePathNode: (row, col) => dispatch(togglePathNode(row, col)),\r\n        resetDataStructure: () => dispatch(resetDataStructure()),\r\n        setDataStructure: (dataStructure) => dispatch(setDataStructure(dataStructure)),\r\n        notShowingPath: () => dispatch(notShowingPath()),\r\n        markHeadNode: (row, col) => dispatch(markHeadNode(row, col)),\r\n        unmarkHeadNode: (row, col) => dispatch(unmarkHeadNode(row, col)),\r\n        resetBoardWithWalls: () => dispatch(resetBoardWithWalls())\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Menu);","import React from 'react';\r\n\r\nconst LegendItem = ({nodeType}) => {\r\n    return (\r\n        <div className=\"column\" style={{margin: \"0 5vh 5vh 3vh\"}}>\r\n            <div className={`node node-${nodeType}`} style={{border: \"2px solid white\", borderRadius: \"5px\"}}></div>\r\n            <div>{nodeType}</div>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst InfoPanel = () => {\r\n    return (\r\n        <div className=\"ui center aligned grid\">\r\n            <div className=\"row \"style={{margin: \"2vh 0 0 0\"}}><h2 className=\"ui dividing header\">Legend</h2></div>\r\n            <LegendItem nodeType={'unvisited'} />\r\n            <LegendItem nodeType={'start'} />\r\n            <LegendItem nodeType={'finish'} />\r\n            <LegendItem nodeType={'wall'} />\r\n            <LegendItem nodeType={'visited'} />\r\n            <LegendItem nodeType={'frontier'} />\r\n            <LegendItem nodeType={'path'} />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default InfoPanel;","import React from 'react';\r\nimport Grid from './Grid';\r\nimport Menu from './Menu';\r\nimport InfoPanel from './InfoPanel';\r\nimport '../css/App.css';\r\n\r\nclass App extends React.Component {\r\n\r\n    render() {\r\n        return (\r\n            <div id=\"wrapper\" className=\"App\">\r\n                <Menu/>\r\n                <Grid />\r\n                <InfoPanel/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport { createStore } from 'redux';\r\nimport reducer from './reducers';\r\nimport App from './components/App';\r\nimport './css/App.css';\r\n\r\nexport const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\r\n\r\nReactDOM.render(<Provider store={store}><App /></Provider>, document.querySelector('#root'));\r\n"],"sourceRoot":""}