{"version":3,"sources":["constants.js","util/GridGenerationUtil.js","reducers/index.js","components/Node.js","actions/index.js","components/Grid.js","util/AlgorithmUtil.js","util/algorithms/BFS.js","util/algorithms/DFS.js","components/SelectAlgorithmDropdown.js","components/Menu.js","components/InfoPanel.js","components/App.js","index.js"],"names":["gridDetails","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","TOTAL_ROW","TOTAL_COL","generateInitalGrid","row","col","grid","r","currentRow","c","push","isStart","isFinish","distance","Infinity","isVisited","isWall","isFrontier","isHead","isBacktrack","previousNode","isPath","generateToggleWallGrid","currentGrid","newGrid","slice","node","newNode","generateToggleFrontierGrid","generateMarkVisitedGrid","generateMarkPathGrid","generateGridWithWalls","currentNode","generateMarkHeadGrid","generateUnmarkHeadGrid","generateMarkBacktrackGrid","array","i","length","generateNodeKey","toString","combineReducers","algorithmStatus","state","action","type","selectedAlgorithm","isShowingPath","payload","dataStructure","isMousePressed","connect","ownProps","dispatch","onMouseDown","toggleWallNode","mouseIsNotPressed","nodeType","id","className","onMouseUp","onMouseEnter","Grid","this","props","map","rowIndex","key","colIndex","React","Component","sleep","ms","Promise","resolve","setTimeout","getNodeNeighbours","neighbours","upNode","rightNode","downNode","leftNode","isAlgorithmRunning","console","log","store","getState","isAlgorithmPaused","isAlgorithmStopped","showPath","togglePathNode","a","finishNode","stack","Stack","undefined","isEmpty","pop","BFS","toggleVisitedNode","toggleFrontierNode","setDataStructure","queue","Queue","startNode","enqueue","dequeue","neighbour","DFS","markHeadNode","unmarkHeadNode","markBacktrackNodes","stacks","unvisitedStack","visitedStack","wasBacktracking","backtrack","removeFromStack","filter","backtrackNodes","visitedNode","contains","peek","target","newStack","tempStack","current","options","text","value","SelectAlgorithmDropdown","selectedAlgorithmText","disabled","Dropdown","fluid","simple","item","onChange","event","data","algorithm","Menu","runSelectedAlgorithm","bind","clearBoard","runAlgorithm","pauseAlgorithm","completeAlgorithm","bfs","run","dfs","clearWall","notShowingPath","stopAlgorithm","resetDataStructure","showInitialBoard","resetBoardWithWalls","runButtonClass","runButtonText","onClick","LegendItem","style","margin","border","borderRadius","InfoPanel","App","createStore","reducer","window","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","render","document","querySelector"],"mappings":"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","file":"static/js/main.35c0a315.chunk.js","sourcesContent":["export const gridDetails = {\r\n    TOTAL_ROW: 21,\r\n    TOTAL_COL: 50,\r\n    START_NODE_ROW: 10,\r\n    START_NODE_COL: 5,\r\n    FINISH_NODE_ROW: 10,\r\n    FINISH_NODE_COL: 45 \r\n}","import { gridDetails } from '../constants';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL, TOTAL_ROW, TOTAL_COL} = gridDetails;\r\n\r\nfunction NodeFactory(row, col) {\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        isFrontier: false,\r\n        isHead: false,\r\n        isBacktrack: false,\r\n        previousNode: null,\r\n        isPath: false\r\n      };\r\n}\r\n\r\nexport function generateInitalGrid() {\r\n    const grid = [];\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        const currentRow = [];\r\n\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            currentRow.push(NodeFactory(r, c));\r\n        }\r\n\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    return grid;\r\n}\r\n\r\nexport function generateToggleWallGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateToggleFrontierGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isFrontier: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkVisitedGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isVisited: true,\r\n        isFrontier: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkPathGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isPath: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateGridWithWalls(currentGrid) {\r\n    const newGrid = generateInitalGrid();\r\n\r\n    for(let r = 0; r < TOTAL_ROW; r++) {\r\n        for(let c = 0; c < TOTAL_COL; c++) {\r\n            const currentNode = currentGrid[r][c];\r\n            if(!currentNode.isFinish && !currentNode.isStart) {  \r\n                newGrid[r][c].isWall = currentNode.isWall;\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: true\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateUnmarkHeadGrid(row, col, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n    const node = newGrid[row][col];\r\n\r\n    const newNode = {\r\n        ...node,\r\n        isHead: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateMarkBacktrackGrid(array, currentGrid) {\r\n    const newGrid = currentGrid.slice();\r\n\r\n    for(let i = 0; i < array.length; i++) {\r\n        const { row, col } = array[i];\r\n        const node = newGrid[row][col];\r\n\r\n        const newNode = {\r\n            ...node,\r\n            isBacktrack: true\r\n        };\r\n        newGrid[row][col] = newNode;\r\n    }\r\n            \r\n    return newGrid;\r\n}\r\n\r\nexport function generateNodeKey(row, col) {\r\n    return (row * TOTAL_ROW + col).toString();\r\n}","import { combineReducers } from 'redux';\r\nimport { generateInitalGrid, generateToggleWallGrid, generateToggleFrontierGrid, generateMarkVisitedGrid, generateMarkPathGrid, generateGridWithWalls, generateMarkHeadGrid, generateUnmarkHeadGrid, generateMarkBacktrackGrid } from '../util/GridGenerationUtil'\r\n\r\nconst gridReducer = (state=generateInitalGrid(), action) => {\r\n    switch(action.type) {\r\n        case 'TOOGLE_WALL_NODE':\r\n            return generateToggleWallGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'TOGGLE_FRONTIER_NDOE':\r\n            return generateToggleFrontierGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'TOGGLE_VISITED_NODE':\r\n            return generateMarkVisitedGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'TOGGLE_PATH_NODE':\r\n            return generateMarkPathGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'SHOW_INITIAL_BOARD':\r\n            return generateInitalGrid();\r\n\r\n        case 'RESET_BOARD_WITH_WALLS':\r\n            return generateGridWithWalls(state);\r\n\r\n        case 'MARK_HEAD_NODE':\r\n            return generateMarkHeadGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'UNMARK_HEAD_NODE':\r\n            return generateUnmarkHeadGrid(action.payload.row, action.payload.col, state);\r\n\r\n        case 'MARK_BACKTRACK_NODE':\r\n            return generateMarkBacktrackGrid(action.payload.array, state);\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst dataStructureReducer = (state=null, action) => {\r\n    switch(action.type) {\r\n        case 'RESET_DATA_STRUCTURE':\r\n            return null;\r\n\r\n        case 'SET_DATA_STRUCTURE':\r\n            return action.payload;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst mousePressedReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'PRESSED':\r\n            return true;\r\n\r\n        case 'NOT_PRESSED':\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst selectAlgorithmReducer = (state='none', action) => {\r\n    switch(action.type) {\r\n        case 'BFS':\r\n            return 'BFS';\r\n\r\n        case 'DFS':\r\n            return 'DFS';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst algorithmStatusReducer = (state='STOPPED', action) => {\r\n    switch(action.type) {\r\n        case 'RUN_ALGORITHM':\r\n            return 'RUNNING';\r\n\r\n        case 'STOP_ALGORITHM':\r\n            return 'STOPPED';\r\n\r\n        case 'PAUSE_ALGORITHM':\r\n            return 'PAUSED';\r\n\r\n        case 'COMPLETE_ALGORITHM':\r\n            return 'COMPLETE';\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst isShowingPathReducer = (state=false, action) => {\r\n    switch(action.type) {\r\n        case 'SHOWING_PATH':\r\n            return true;\r\n\r\n        case 'NOT_SHOWING_PATH':\r\n            return false;\r\n        \r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default combineReducers({\r\n    algorithmStatus: algorithmStatusReducer,\r\n    selectedAlgorithm: selectAlgorithmReducer,\r\n    isShowingPath: isShowingPathReducer,\r\n    grid: gridReducer,\r\n    dataStructure: dataStructureReducer,\r\n    isMousePressed: mousePressedReducer\r\n});","import '../css/Node.css';\r\nimport React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { mouseIsNotPressed, onMouseDown } from '../actions'\r\n\r\nconst Node = ({ row, col, isStart, isFinish, isWall, isHead, isVisited, isFrontier, isPath, isBacktrack, isMousePressed, onMouseDown, mouseIsNotPressed}) => {\r\n    const nodeType = isFinish\r\n        ? 'node-finish'\r\n        : isStart\r\n        ? 'node-start'\r\n        : isPath\r\n        ? 'node-path'\r\n        : isWall\r\n        ? 'node-wall'\r\n        : isHead\r\n        ? 'node-head'\r\n        : isBacktrack\r\n        ? 'node-backtrack'\r\n        : isVisited\r\n        ? 'node-visited'\r\n        : isFrontier\r\n        ? 'node-frontier'\r\n        : ''\r\n\r\n    return <div \r\n            id={`node-${row}-${col}`}\r\n            className={`node ${nodeType}`}\r\n            onMouseDown={(!isFrontier && !isVisited && !isFinish && !isStart) ? onMouseDown : () => {}}\r\n            onMouseUp={mouseIsNotPressed}\r\n            onMouseEnter={(isMousePressed && !isWall && !isFrontier && !isVisited && !isFinish && !isStart) ? onMouseDown : () => {}}></div>\r\n}\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n    const node = state.grid[ownProps.row][ownProps.col];\r\n\r\n    return {\r\n        isStart:  node.isStart,\r\n        isFinish: node.isFinish,\r\n        isWall: node.isWall,\r\n        isFrontier: node.isFrontier,\r\n        isVisited: node.isVisited,\r\n        isPath: node.isPath,\r\n        isHead: node.isHead,\r\n        isBacktrack: node.isBacktrack,\r\n        isMousePressed: state.isMousePressed\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch, ownProps) => {\r\n    return {\r\n        onMouseDown: () => onMouseDown(ownProps.row, ownProps.col, dispatch),\r\n        mouseIsNotPressed: () => dispatch(mouseIsNotPressed()),\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Node);","const toggleWallNode = (row, col) => {\r\n    return {\r\n        type: 'TOOGLE_WALL_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nconst mouseIsPressed = () => {\r\n    return { type: 'PRESSED'};\r\n}\r\n\r\nexport const mouseIsNotPressed = () => {\r\n    return { type: 'NOT_PRESSED'};\r\n}\r\n\r\nexport const onMouseDown = (row, col, dispatch) => {\r\n    dispatch(toggleWallNode(row, col));\r\n    dispatch(mouseIsPressed());\r\n}\r\n\r\n\r\nexport const runAlgorithm = () => {\r\n    return { type: 'RUN_ALGORITHM'};\r\n}\r\n\r\nexport const stopAlgorithm = () => {\r\n    return { type: 'STOP_ALGORITHM'};\r\n}\r\n\r\nexport const showInitialBoard = () => {\r\n    return { type: 'SHOW_INITIAL_BOARD'};\r\n}\r\n\r\nexport const resetBoardWithWalls = () => {\r\n    return { type: 'RESET_BOARD_WITH_WALLS'};\r\n}\r\n\r\nexport const pauseAlgorithm = () => {\r\n    return { type: 'PAUSE_ALGORITHM'};\r\n}\r\n\r\nexport const completeAlgorithm = () => {\r\n    return { type: 'COMPLETE_ALGORITHM'};\r\n}\r\n\r\nexport const toggleFrontierNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_FRONTIER_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const toggleVisitedNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_VISITED_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const togglePathNode = (row, col) => {\r\n    return {\r\n        type: 'TOGGLE_PATH_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const setSelectedAlgorithm = (algorithmName) => {\r\n    return {\r\n        type: algorithmName\r\n    }\r\n}\r\n\r\nexport const resetDataStructure = () => {\r\n    return { type: 'RESET_DATA_STRUCTURE' }\r\n}\r\n\r\nexport const setDataStructure = (dataStructure) => {\r\n    return {\r\n        type: 'SET_DATA_STRUCTURE',\r\n        payload: dataStructure\r\n    }\r\n}\r\n\r\nexport const showingPath = () => {\r\n    return { type: 'SHOWING_PATH' };\r\n}\r\n\r\nexport const notShowingPath = () => {\r\n    return { type: 'NOT_SHOWING_PATH' };\r\n}\r\n\r\nexport const markHeadNode = (row, col) => {\r\n    return {\r\n        type: 'MARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const unmarkHeadNode = (row, col) => {\r\n    return {\r\n        type: 'UNMARK_HEAD_NODE',\r\n        payload: {\r\n            row, col\r\n        }\r\n    }\r\n}\r\n\r\nexport const markBacktrackNodes = (array) => {\r\n    return  {\r\n        type: 'MARK_BACKTRACK_NODE',\r\n        payload: { array }\r\n    }\r\n}\r\n","import React from 'react';\r\nimport Node from './Node';\r\nimport { connect } from 'react-redux';\r\nimport '../css/Grid.css';\r\nimport { generateNodeKey } from '../util/GridGenerationUtil'\r\n\r\nclass Grid extends React.Component {\r\n\r\n    render() {\r\n        const {grid} = this.props;\r\n\r\n        return (\r\n            <div className=\"grid\">\r\n                {\r\n                    grid.map((row, rowIndex) => {\r\n                        return (\r\n                            <div className=\"grid-row\" key={rowIndex}>\r\n                                {\r\n                                    row.map((col, colIndex) => {\r\n                                        return (<Node \r\n                                                    key={generateNodeKey(rowIndex, colIndex)}\r\n                                                    row={rowIndex} \r\n                                                    col={colIndex}/>);\r\n                                    })\r\n                                }\r\n                            </div>\r\n                        )\r\n                        \r\n                    })\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.grid,\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Grid);","import { gridDetails } from '../constants';\r\nimport { store } from '../index';\r\nimport Stack from '@datastructures-js/stack';\r\nimport { showingPath, notShowingPath } from '../actions';\r\n\r\nconst { TOTAL_ROW, TOTAL_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n\r\nexport function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nexport const getNodeNeighbours = (state, node) => {\r\n    let neighbours = [];\r\n\r\n    if(node.row > 0) {\r\n        const upNode = state[node.row - 1][node.col];\r\n        neighbours.push(upNode);\r\n    }\r\n\r\n    if(node.col < (TOTAL_COL - 1)) {\r\n        const rightNode = state[node.row][node.col + 1];\r\n        neighbours.push(rightNode);\r\n    }\r\n\r\n    if(node.row < (TOTAL_ROW - 1)) {\r\n        const downNode = state[node.row + 1][node.col];\r\n        neighbours.push(downNode);\r\n    }\r\n\r\n    if(node.col > 0) {\r\n        const leftNode = state[node.row][node.col - 1];\r\n        neighbours.push(leftNode);\r\n    }\r\n\r\n    return neighbours;\r\n}\r\n\r\nexport const isAlgorithmRunning = () => {\r\n    console.log(`isAlgorithmRunning:${store.getState().algorithmStatus} `)\r\n    return (store.getState().algorithmStatus === 'RUNNING');\r\n}\r\n\r\nexport const isAlgorithmPaused = () => {\r\n    return (store.getState().algorithmStatus === 'PAUSED');\r\n}\r\n\r\nexport const isAlgorithmStopped = () => {\r\n    return (store.getState().algorithmStatus === 'STOPPED');\r\n}\r\n\r\nconst isShowingPath = () => {\r\n    return store.getState().isShowingPath;\r\n}\r\n\r\nexport async function showPath(state, togglePathNode) {\r\n    store.dispatch(showingPath());\r\n\r\n    const finishNode = state[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let currentNode = finishNode;\r\n    const stack = new Stack();\r\n    while(currentNode !== undefined) {\r\n        stack.push(currentNode);\r\n\r\n        if(!currentNode.previousNode) {\r\n            break;\r\n        }\r\n        currentNode = state[currentNode.previousNode.row][currentNode.previousNode.col];\r\n    }\r\n\r\n    while(!stack.isEmpty()) {\r\n        if(isAlgorithmStopped() || !isShowingPath()) {\r\n            return;\r\n        }\r\n\r\n        let node = stack.pop();\r\n        togglePathNode(node.row, node.col);\r\n        await sleep(20);\r\n    }\r\n\r\n    store.dispatch(notShowingPath());\r\n}","import { gridDetails } from '../../constants';\r\nimport { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\n\r\nimport Queue from 'queue-fifo';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n  \r\nexport default class BFS {\r\n    constructor(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure) {\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, queue) {\r\n        if(queue === null) {\r\n            queue = new Queue();\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            queue.enqueue(startNode);\r\n        }\r\n\r\n        while(!queue.isEmpty() && isAlgorithmRunning()) {\r\n            const currentNode = queue.dequeue();\r\n            currentNode.isFrontier = false;\r\n            currentNode.isVisited = true;\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                await showPath(grid, this.togglePathNode);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = 0; i < neighbours.length; i++) {\r\n                const neighbour = neighbours[i];\r\n                if(!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) {\r\n\r\n                    if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                        await showPath(grid, this.togglePathNode);\r\n                        return;\r\n                    }\r\n\r\n                    neighbour.isFrontier = true;\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    this.toggleFrontierNode(neighbour.row, neighbour.col);\r\n                    queue.enqueue(neighbour);\r\n                }\r\n            }\r\n            await sleep(0);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure(queue);\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n        \r\n    }\r\n}\r\n","import { gridDetails } from '../../constants';\r\nimport { getNodeNeighbours, sleep , isAlgorithmRunning, isAlgorithmPaused, isAlgorithmStopped, showPath} from '../AlgorithmUtil';\r\nimport Stack from '@datastructures-js/stack';\r\n\r\nconst  {START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = gridDetails;\r\n\r\nexport default class DFS {\r\n    constructor(toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, markBacktrackNodes, setDataStructure) {\r\n        this.toggleVisitedNode = toggleVisitedNode;\r\n        this.toggleFrontierNode = toggleFrontierNode;\r\n        this.togglePathNode = togglePathNode;\r\n        this.markHeadNode = markHeadNode;\r\n        this.unmarkHeadNode = unmarkHeadNode;\r\n        this.markBacktrackNodes = markBacktrackNodes;\r\n        this.setDataStructure = setDataStructure;\r\n    }\r\n\r\n    async run(grid, stacks) {\r\n        let unvisitedStack = null;\r\n        let visitedStack = null;\r\n        let wasBacktracking = null;\r\n\r\n        if(stacks === null) {\r\n            unvisitedStack = new Stack();\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            unvisitedStack.push(startNode);\r\n\r\n            visitedStack = new Stack();\r\n            wasBacktracking = false;\r\n        } else {\r\n            unvisitedStack = stacks.unvisitedStack;\r\n            visitedStack = stacks.visitedStack;\r\n            wasBacktracking = stacks.wasBacktracking;\r\n        }\r\n\r\n        while(!unvisitedStack.isEmpty() && isAlgorithmRunning()) {\r\n            if(wasBacktracking) {\r\n                wasBacktracking = await this.backtrack(visitedStack, unvisitedStack, grid);\r\n                await sleep(20);\r\n                continue;\r\n            }\r\n\r\n\r\n            const currentNode = unvisitedStack.pop();\r\n            unvisitedStack = this.removeFromStack(unvisitedStack, currentNode);\r\n\r\n            currentNode.isVisited = true;\r\n            currentNode.isHead = true;\r\n            this.markHeadNode(currentNode.row, currentNode.col);\r\n            this.toggleVisitedNode(currentNode.row, currentNode.col);\r\n\r\n            if(currentNode.previousNode !== null) {\r\n                const { row, col } = currentNode.previousNode;\r\n                grid[row][col].isHead = false;\r\n                this.unmarkHeadNode(row, col);\r\n            }\r\n\r\n            if(currentNode.row === FINISH_NODE_ROW && currentNode.col === FINISH_NODE_COL) {\r\n                await showPath(grid, this.togglePathNode);\r\n                return;\r\n            }\r\n\r\n            const neighbours = getNodeNeighbours(grid, currentNode);\r\n            for(let i = neighbours.length - 1; i >= 0; i--) {\r\n                const neighbour = neighbours[i];\r\n                if(!neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier) {\r\n                    neighbour.previousNode = { row: currentNode.row, col: currentNode.col};\r\n                    unvisitedStack.push(neighbour);\r\n                }\r\n            }\r\n\r\n            visitedStack.push(currentNode);\r\n\r\n            const validNeighbours = neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier)\r\n\r\n            if(validNeighbours.length === 0) {\r\n                // console.log(`deadend: ${currentNode.row}, ${currentNode.col}`)\r\n                // console.log(`unvisited: ${unvisitedStack.toArray().map(i => `(${i.row}, ${i.col}) `)}`)\r\n                // console.log(`visited: ${visitedStack.toArray().map(i => `(${i.row}, ${i.col}) `)}`)\r\n                currentNode.isHead = false;\r\n                this.unmarkHeadNode(currentNode.row, currentNode.col);\r\n                await sleep(20);\r\n                wasBacktracking = await this.backtrack(visitedStack, unvisitedStack, grid);\r\n               \r\n            }\r\n\r\n            await sleep(50);\r\n        }\r\n\r\n        if(isAlgorithmPaused()) {\r\n            this.setDataStructure({ unvisitedStack: unvisitedStack, visitedStack: visitedStack, wasBacktracking: wasBacktracking });\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmStopped()) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    async backtrack(visitedStack, unvisitedStack, grid) {\r\n\r\n        let backtrackNodes = [];\r\n\r\n        while(!visitedStack.isEmpty() && !unvisitedStack.isEmpty() && isAlgorithmRunning()) {\r\n            const visitedNode = visitedStack.pop();\r\n\r\n            let neighbours = getNodeNeighbours(grid, visitedNode);\r\n            neighbours = neighbours.filter(neighbour => !neighbour.isWall && !neighbour.isVisited && !neighbour.isFrontier)\r\n            if(this.contains(neighbours, unvisitedStack.peek())) {\r\n                // console.log(`backtrack ${unvisitedStack.peek().row}, ${unvisitedStack.peek().col}`)\r\n                visitedStack.push(visitedNode);\r\n                this.markBacktrackNodes(backtrackNodes);\r\n                return;\r\n            } else {\r\n                backtrackNodes.push(visitedNode);\r\n            }   \r\n        }\r\n\r\n    }\r\n\r\n    contains(neighbours, target) {\r\n        for(let i = 0; i < neighbours.length; i++) {\r\n            const neighbour = neighbours[i];\r\n            if(neighbour.row === target.row && neighbour.col === target.col) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n\r\n        return false;\r\n    }\r\n\r\n    removeFromStack(stack, target) {\r\n        const newStack = new Stack();\r\n        const tempStack = new Stack();\r\n\r\n        while(!stack.isEmpty()) {\r\n            const current = stack.pop();\r\n            if(current.row === target.row && current.col === target.col) {\r\n                continue;\r\n            }\r\n\r\n            tempStack.push(current);\r\n        }\r\n\r\n        while(!tempStack.isEmpty()) {\r\n            newStack.push(tempStack.pop());\r\n        }\r\n\r\n        return newStack;\r\n    }\r\n}\r\n","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Dropdown } from 'semantic-ui-react';\r\nimport { setSelectedAlgorithm } from '../actions';\r\n\r\nconst options = [\r\n    { key: 1, text: 'Breadth First Search (BFS)', value: 'BFS' },\r\n    { key: 2, text: 'Depth First Search (DFS)', value: 'DFS' }\r\n  ]\r\n\r\nclass SelectAlgorithmDropdown extends React.Component {\r\n    render() {\r\n        const selectedAlgorithmText = this.props.selectedAlgorithm === 'none' ? 'Select Algorithm' \r\n                                                                              : this.props.selectedAlgorithm === 'BFS'\r\n                                                                              ? 'Breadth First Search (BFS)'\r\n                                                                              : this.props.selectedAlgorithm === 'DFS'\r\n                                                                              ? 'Depth First Search (BFS)'\r\n                                                                              : 'Select Algorithm';\r\n\r\n        const disabled = this.props.algorithmStatus !== 'STOPPED';\r\n\r\n        return (\r\n            <Dropdown \r\n                fluid text={selectedAlgorithmText} \r\n                options={options} \r\n                simple item onChange={(event, data) => {this.props.onChange(data.value)}}\r\n                disabled={disabled}/>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        onChange: (algorithm) => {dispatch(setSelectedAlgorithm(algorithm))}\r\n    }\r\n}\r\n  \r\nexport default connect(mapStateToProps, mapDispatchToProps)(SelectAlgorithmDropdown)","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { showInitialBoard, runAlgorithm, stopAlgorithm, pauseAlgorithm, completeAlgorithm, toggleFrontierNode, toggleVisitedNode, togglePathNode, resetDataStructure, setDataStructure, notShowingPath, markHeadNode, unmarkHeadNode, resetBoardWithWalls, markBacktrackNodes } from '../actions';\r\nimport BFS from '../util/algorithms/BFS';\r\nimport DFS from '../util/algorithms/DFS';\r\nimport { isAlgorithmRunning } from '../util/AlgorithmUtil'\r\nimport SelectAlgorithmDropdown from './SelectAlgorithmDropdown';\r\n\r\nclass Menu extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.runSelectedAlgorithm = this.runSelectedAlgorithm.bind(this);\r\n        this.clearBoard = this.clearBoard.bind(this);\r\n\r\n    }\r\n\r\n    async runSelectedAlgorithm() {\r\n        const { selectedAlgorithm, \r\n                runAlgorithm, \r\n                pauseAlgorithm,\r\n                completeAlgorithm, \r\n                grid,\r\n                dataStructure,\r\n                toggleVisitedNode, \r\n                toggleFrontierNode, \r\n                togglePathNode,\r\n                setDataStructure,\r\n                isShowingPath,\r\n                markHeadNode,\r\n                unmarkHeadNode,\r\n                algorithmStatus,\r\n                markBacktrackNodes } = this.props;\r\n\r\n        if(selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') {\r\n            return;\r\n        }\r\n\r\n        if(isAlgorithmRunning()) {\r\n            pauseAlgorithm();\r\n            return;\r\n        }\r\n\r\n        runAlgorithm();\r\n\r\n        switch(selectedAlgorithm) {\r\n            case \"BFS\":\r\n                const bfs = new BFS(toggleVisitedNode, toggleFrontierNode, togglePathNode, setDataStructure);\r\n                await bfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            case \"DFS\":\r\n                const dfs = new DFS(toggleVisitedNode, toggleFrontierNode, togglePathNode, markHeadNode, unmarkHeadNode, markBacktrackNodes, setDataStructure);\r\n                await dfs.run(grid, dataStructure);\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        \r\n        if(isAlgorithmRunning()) {\r\n            completeAlgorithm();\r\n        }\r\n\r\n    }\r\n\r\n    clearBoard(clearWall) {\r\n        this.props.notShowingPath();\r\n        this.props.stopAlgorithm();\r\n        this.props.resetDataStructure();\r\n\r\n        if(clearWall) {\r\n            this.props.showInitialBoard();\r\n        } else {\r\n            this.props.resetBoardWithWalls();\r\n        }\r\n        \r\n    }\r\n\r\n    render() {\r\n        const { selectedAlgorithm, algorithmStatus, isShowingPath } = this.props;\r\n\r\n        const runButtonClass = (selectedAlgorithm === 'none' || isShowingPath || algorithmStatus === 'COMPLETE') ? \"active item\" : \"item\";\r\n\r\n        let runButtonText = \"Run\";\r\n        if((algorithmStatus === 'RUNNING' && isShowingPath) || algorithmStatus === 'COMPLETE') {\r\n            runButtonText = \"Complete\";\r\n        }\r\n\r\n        if(algorithmStatus === 'RUNNING' && !isShowingPath) {\r\n            runButtonText = \"Pause\";\r\n        }\r\n\r\n        return (\r\n            <div className=\"ui four item menu\">\r\n                <a  onClick={this.runSelectedAlgorithm} className={runButtonClass}>{runButtonText}!</a>\r\n                <SelectAlgorithmDropdown />\r\n                <a onClick={() => this.clearBoard(false)} className=\"item\">Clear Path</a>\r\n                <a onClick={() => this.clearBoard(true)} className=\"item\">Clear Board</a>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        grid: state.grid,\r\n        dataStructure: state.dataStructure,\r\n        selectedAlgorithm: state.selectedAlgorithm,\r\n        algorithmStatus: state.algorithmStatus,\r\n        isShowingPath: state.isShowingPath\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        showInitialBoard: () => dispatch(showInitialBoard()),\r\n        runAlgorithm: () => dispatch(runAlgorithm()),\r\n        stopAlgorithm: () => dispatch(stopAlgorithm()),\r\n        pauseAlgorithm: () => dispatch(pauseAlgorithm()),\r\n        completeAlgorithm: () => dispatch(completeAlgorithm()),\r\n        toggleVisitedNode: (row, col) => dispatch(toggleVisitedNode(row, col)),\r\n        toggleFrontierNode: (row, col) => dispatch(toggleFrontierNode(row, col)),\r\n        togglePathNode: (row, col) => dispatch(togglePathNode(row, col)),\r\n        resetDataStructure: () => dispatch(resetDataStructure()),\r\n        setDataStructure: (dataStructure) => dispatch(setDataStructure(dataStructure)),\r\n        notShowingPath: () => dispatch(notShowingPath()),\r\n        markHeadNode: (row, col) => dispatch(markHeadNode(row, col)),\r\n        unmarkHeadNode: (row, col) => dispatch(unmarkHeadNode(row, col)),\r\n        resetBoardWithWalls: () => dispatch(resetBoardWithWalls()),\r\n        markBacktrackNodes: (array) => dispatch(markBacktrackNodes(array))\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Menu);","import React from 'react';\r\n\r\nconst LegendItem = ({nodeType}) => {\r\n    return (\r\n        <div className=\"column\" style={{margin: \"0 5vh 5vh 3vh\"}}>\r\n            <div className={`node node-${nodeType}`} style={{border: \"2px solid white\", borderRadius: \"5px\"}}></div>\r\n            <div>{nodeType}</div>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst InfoPanel = () => {\r\n    return (\r\n        <div className=\"ui center aligned grid\">\r\n            <div className=\"row \"style={{margin: \"2vh 0 0 0\"}}><h2 className=\"ui dividing header\">Legend</h2></div>\r\n            <LegendItem nodeType={'unvisited'} />\r\n            <LegendItem nodeType={'start'} />\r\n            <LegendItem nodeType={'finish'} />\r\n            <LegendItem nodeType={'wall'} />\r\n            <LegendItem nodeType={'visited'} />\r\n            <LegendItem nodeType={'backtrack'} />\r\n            <LegendItem nodeType={'frontier'} />\r\n            <LegendItem nodeType={'path'} />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default InfoPanel;","import React from 'react';\r\nimport Grid from './Grid';\r\nimport Menu from './Menu';\r\nimport InfoPanel from './InfoPanel';\r\nimport '../css/App.css';\r\n\r\nclass App extends React.Component {\r\n\r\n    render() {\r\n        return (\r\n            <div id=\"wrapper\" className=\"App\">\r\n                <Menu/>\r\n                <Grid />\r\n                <InfoPanel/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { Provider } from 'react-redux';\r\nimport { createStore } from 'redux';\r\nimport reducer from './reducers';\r\nimport App from './components/App';\r\nimport './css/App.css';\r\n\r\nexport const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\r\n\r\nReactDOM.render(<Provider store={store}><App /></Provider>, document.querySelector('#root'));\r\n"],"sourceRoot":""}